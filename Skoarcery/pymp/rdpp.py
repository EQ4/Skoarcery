# ==================================================================================================================
# rdpp.py - Generated by PyRDPP - Create Recursive Descent Predictive Parser on 2014-04-29 08:50:38 for Python 3.3.2
# ==================================================================================================================
from Skoarcery.pymp.lex import Toke_Loco, Toke_Tuplet, Toke_Eighths, Toke_PedalUp, Toke_AssOp, \
    Toke_ListS, Toke_AccSharp, Toke_Portamento, Toke_String, Toke_AlCoda, \
    Toke_QuindicesimaB, Toke_ListE, Toke_Quavers, Toke_CondSep, Toke_DynPiano, \
    Toke_Coda, Toke_NoatSharps, Toke_AlFine, Toke_BassClef, Toke_DubRep, \
    Toke_Quarters, Toke_Float, Toke_MsgNameWithArgs, Toke_AlSegno, Toke_Bars, \
    Toke_Rep, Toke_CurNoat, Toke_AccNatural, Toke_Crotchets, Toke_Volta, \
    Toke_Fine, Toke_LWing, Toke_NoatFlats, Toke_QuindicesimaA, Toke_DynSFZ, \
    Toke_VectorNoat, Toke_Comment, Toke_PedalDown, Toke_CondS, Toke_Symbol, \
    Toke_DynFP, Toke_EOF, Toke_Segno, Toke_Int, Toke_AltoClef, \
    Toke_AccFlat, Toke_CondE, Toke_Carrots, Toke_TrebleClef, Toke_OttavaB, \
    Toke_OttavaA, Toke_Slur, Toke_Slash, Toke_BooleanOp, Toke_Nosey, \
    Toke_Caesura, Toke_WS, Toke_DalSegno, Toke_MsgName, Toke_Choard, \
    Toke_DynForte, Toke_MsgOp, Toke_MeterE, Toke_DaCapo, Toke_ListSep, \
    Toke_RWing, Toke_MeterS


class SkoarParseException(Exception):
    pass


class SkoarParser:

    def __init__(self, toker):
        self.toker = toker
        self.tab = 0

    def fail(self):
        self.toker.dump()
        raise SkoarParseException

    @property
    def tabby(self):
        if self.tab == 0:
            return ""

        return ("{:>" + str(self.tab * 4) + "}").format(" ")

    def print(self, line, end):
        print(self.tabby + line, end=end)


    def phrases(self):
        # phrases -> phrasey phrases
        desires = [Toke_Quavers, Toke_Eighths, Toke_PedalUp, Toke_DaCapo, Toke_AccSharp,
                   Toke_Coda, Toke_String, Toke_QuindicesimaB, Toke_Slash, Toke_DubRep,
                   Toke_Quarters, Toke_Float, Toke_ListS, Toke_Bars, Toke_Rep,
                   Toke_Loco, Toke_AccNatural, Toke_Tuplet, Toke_Fine, Toke_LWing,
                   Toke_DynSFZ, Toke_VectorNoat, Toke_Comment, Toke_PedalDown, Toke_CondS,
                   Toke_Symbol, Toke_DynFP, Toke_Int, Toke_Portamento, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Crotchets, Toke_OttavaB, Toke_OttavaA,
                   Toke_Caesura, Toke_DynPiano, Toke_DalSegno, Toke_Choard, Toke_DynForte,
                   Toke_Slur, Toke_Segno, Toke_MeterS]
        if self.toker.sees(desires):
            self.print('phrases -> phrasey phrases', end='\n')
            self.phrasey()
            self.phrases()
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def moar_listy_entries(self):
        # moar_listy_entries -> ListSep listy_entries
        desires = [Toke_ListSep]
        if self.toker.sees(desires):
            self.print('moar_listy_entries -> ListSep listy_entries', end='\n')
            self.toker.burn(Toke_ListSep)
            self.print('burning: ListSep', end='\n')
            self.listy_entries()
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def clef(self):
        # clef -> TrebleClef
        desires = [Toke_TrebleClef]
        if self.toker.sees(desires):
            self.print('clef -> TrebleClef', end='\n')
            self.toker.burn(Toke_TrebleClef)
            self.print('burning: TrebleClef', end='\n')
            return

        # clef -> BassClef
        desires = [Toke_BassClef]
        if self.toker.sees(desires):
            self.print('clef -> BassClef', end='\n')
            self.toker.burn(Toke_BassClef)
            self.print('burning: BassClef', end='\n')
            return

        # clef -> AltoClef
        desires = [Toke_AltoClef]
        if self.toker.sees(desires):
            self.print('clef -> AltoClef', end='\n')
            self.toker.burn(Toke_AltoClef)
            self.print('burning: AltoClef', end='\n')
            return

        # Error State
        self.fail()

    def phrasey(self):
        # phrasey -> Comment
        desires = [Toke_Comment]
        if self.toker.sees(desires):
            self.print('phrasey -> Comment', end='\n')
            self.toker.burn(Toke_Comment)
            self.print('burning: Comment', end='\n')
            return

        # phrasey -> markers
        desires = [Toke_Bars, Toke_Segno, Toke_Coda, Toke_Fine]
        if self.toker.sees(desires):
            self.print('phrasey -> markers', end='\n')
            self.markers()
            return

        # phrasey -> meter
        desires = [Toke_MeterS]
        if self.toker.sees(desires):
            self.print('phrasey -> meter', end='\n')
            self.meter()
            return

        # phrasey -> skoaroid
        desires = [Toke_Loco, Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat,
                   Toke_ListS, Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown,
                   Toke_Symbol, Toke_String, Toke_DynFP, Toke_Int, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_DynSFZ, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura, Toke_DynPiano,
                   Toke_Choard, Toke_Rep, Toke_DynForte, Toke_CurNoat, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('phrasey -> skoaroid', end='\n')
            self.skoaroid()
            return

        # phrasey -> dal_goto
        desires = [Toke_DalSegno, Toke_DaCapo]
        if self.toker.sees(desires):
            self.print('phrasey -> dal_goto', end='\n')
            self.dal_goto()
            return

        # phrasey -> beat
        desires = [Toke_Quarters, Toke_Eighths, Toke_Quavers, Toke_Slash, Toke_Crotchets]
        if self.toker.sees(desires):
            self.print('phrasey -> beat', end='\n')
            self.beat()
            return

        # Error State
        self.fail()

    def listy(self):
        # listy -> ListS listy_suffix
        desires = [Toke_ListS]
        if self.toker.sees(desires):
            self.print('listy -> ListS listy_suffix', end='\n')
            self.toker.burn(Toke_ListS)
            self.print('burning: ListS', end='\n')
            self.listy_suffix()
            return

        # Error State
        self.fail()

    def msg_chain_node(self):
        # msg_chain_node -> MsgOp msg msg_chain_node
        desires = [Toke_MsgOp]
        if self.toker.sees(desires):
            self.print('msg_chain_node -> MsgOp msg msg_chain_node', end='\n')
            self.toker.burn(Toke_MsgOp)
            self.print('burning: MsgOp', end='\n')
            self.msg()
            self.msg_chain_node()
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def accidentally(self):
        # accidentally -> acc noaty
        desires = [Toke_AccSharp, Toke_AccFlat, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('accidentally -> acc noaty', end='\n')
            self.acc()
            self.noaty()
            return

        # Error State
        self.fail()

    def optional_al_coda(self):
        # optional_al_coda -> AlCoda
        desires = [Toke_AlCoda]
        if self.toker.sees(desires):
            self.print('optional_al_coda -> AlCoda', end='\n')
            self.toker.burn(Toke_AlCoda)
            self.print('burning: AlCoda', end='\n')
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def dal_goto(self):
        # dal_goto -> DaCapo al_whatnow
        desires = [Toke_DaCapo]
        if self.toker.sees(desires):
            self.print('dal_goto -> DaCapo al_whatnow', end='\n')
            self.toker.burn(Toke_DaCapo)
            self.print('burning: DaCapo', end='\n')
            self.al_whatnow()
            return

        # dal_goto -> DalSegno al_whatnow
        desires = [Toke_DalSegno]
        if self.toker.sees(desires):
            self.print('dal_goto -> DalSegno al_whatnow', end='\n')
            self.toker.burn(Toke_DalSegno)
            self.print('burning: DalSegno', end='\n')
            self.al_whatnow()
            return

        # Error State
        self.fail()

    def nouny_literal(self):
        # nouny_literal -> Tuplet
        desires = [Toke_Tuplet]
        if self.toker.sees(desires):
            self.print('nouny_literal -> Tuplet', end='\n')
            self.toker.burn(Toke_Tuplet)
            self.print('burning: Tuplet', end='\n')
            return

        # nouny_literal -> Caesura
        desires = [Toke_Caesura]
        if self.toker.sees(desires):
            self.print('nouny_literal -> Caesura', end='\n')
            self.toker.burn(Toke_Caesura)
            self.print('burning: Caesura', end='\n')
            return

        # nouny_literal -> Slur
        desires = [Toke_Slur]
        if self.toker.sees(desires):
            self.print('nouny_literal -> Slur', end='\n')
            self.toker.burn(Toke_Slur)
            self.print('burning: Slur', end='\n')
            return

        # nouny_literal -> Int
        desires = [Toke_Int]
        if self.toker.sees(desires):
            self.print('nouny_literal -> Int', end='\n')
            self.toker.burn(Toke_Int)
            self.print('burning: Int', end='\n')
            return

        # nouny_literal -> Float
        desires = [Toke_Float]
        if self.toker.sees(desires):
            self.print('nouny_literal -> Float', end='\n')
            self.toker.burn(Toke_Float)
            self.print('burning: Float', end='\n')
            return

        # nouny_literal -> String
        desires = [Toke_String]
        if self.toker.sees(desires):
            self.print('nouny_literal -> String', end='\n')
            self.toker.burn(Toke_String)
            self.print('burning: String', end='\n')
            return

        # Error State
        self.fail()

    def skoaroid(self):
        # skoaroid -> nouny skoaroid_prime
        desires = [Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat, Toke_ListS,
                   Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown, Toke_Symbol,
                   Toke_String, Toke_DynFP, Toke_Int, Toke_CurNoat, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_DynSFZ, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura, Toke_DynPiano,
                   Toke_Choard, Toke_Rep, Toke_DynForte, Toke_Loco, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('skoaroid -> nouny skoaroid_prime', end='\n')
            self.nouny()
            self.skoaroid_prime()
            return

        # Error State
        self.fail()

    def measure_marker(self):
        # measure_marker -> Bars opt_volta
        desires = [Toke_Bars]
        if self.toker.sees(desires):
            self.print('measure_marker -> Bars opt_volta', end='\n')
            self.toker.burn(Toke_Bars)
            self.print('burning: Bars', end='\n')
            self.opt_volta()
            return

        # Error State
        self.fail()

    def msg(self):
        # msg -> MsgNameWithArgs listy_suffix
        desires = [Toke_MsgNameWithArgs]
        if self.toker.sees(desires):
            self.print('msg -> MsgNameWithArgs listy_suffix', end='\n')
            self.toker.burn(Toke_MsgNameWithArgs)
            self.print('burning: MsgNameWithArgs', end='\n')
            self.listy_suffix()
            return

        # msg -> MsgName
        desires = [Toke_MsgName]
        if self.toker.sees(desires):
            self.print('msg -> MsgName', end='\n')
            self.toker.burn(Toke_MsgName)
            self.print('burning: MsgName', end='\n')
            return

        # msg -> listy
        desires = [Toke_ListS]
        if self.toker.sees(desires):
            self.print('msg -> listy', end='\n')
            self.listy()
            return

        # Error State
        self.fail()

    def opt_volta(self):
        # opt_volta -> Volta
        desires = [Toke_Volta]
        if self.toker.sees(desires):
            self.print('opt_volta -> Volta', end='\n')
            self.toker.burn(Toke_Volta)
            self.print('burning: Volta', end='\n')
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def settable(self):
        # settable -> Caesura
        desires = [Toke_Caesura]
        if self.toker.sees(desires):
            self.print('settable -> Caesura', end='\n')
            self.toker.burn(Toke_Caesura)
            self.print('burning: Caesura', end='\n')
            return

        # settable -> CurNoat
        desires = [Toke_CurNoat]
        if self.toker.sees(desires):
            self.print('settable -> CurNoat', end='\n')
            self.toker.burn(Toke_CurNoat)
            self.print('burning: CurNoat', end='\n')
            return

        # settable -> Symbol
        desires = [Toke_Symbol]
        if self.toker.sees(desires):
            self.print('settable -> Symbol', end='\n')
            self.toker.burn(Toke_Symbol)
            self.print('burning: Symbol', end='\n')
            return

        # settable -> listy
        desires = [Toke_ListS]
        if self.toker.sees(desires):
            self.print('settable -> listy', end='\n')
            self.listy()
            return

        # Error State
        self.fail()

    def musical_keyword(self):
        # musical_keyword -> dynamic
        desires = [Toke_DynFP, Toke_DynForte, Toke_DynSFZ, Toke_DynPiano]
        if self.toker.sees(desires):
            self.print('musical_keyword -> dynamic', end='\n')
            self.dynamic()
            return

        # musical_keyword -> ottavas
        desires = [Toke_QuindicesimaB, Toke_OttavaB, Toke_OttavaA, Toke_QuindicesimaA, Toke_Loco]
        if self.toker.sees(desires):
            self.print('musical_keyword -> ottavas', end='\n')
            self.ottavas()
            return

        # musical_keyword -> musical_keyword_misc
        desires = [Toke_PedalDown, Toke_Rep, Toke_Portamento, Toke_PedalUp, Toke_DubRep]
        if self.toker.sees(desires):
            self.print('musical_keyword -> musical_keyword_misc', end='\n')
            self.musical_keyword_misc()
            return

        # Error State
        self.fail()

    def ottavas(self):
        # ottavas -> OttavaA
        desires = [Toke_OttavaA]
        if self.toker.sees(desires):
            self.print('ottavas -> OttavaA', end='\n')
            self.toker.burn(Toke_OttavaA)
            self.print('burning: OttavaA', end='\n')
            return

        # ottavas -> OttavaB
        desires = [Toke_OttavaB]
        if self.toker.sees(desires):
            self.print('ottavas -> OttavaB', end='\n')
            self.toker.burn(Toke_OttavaB)
            self.print('burning: OttavaB', end='\n')
            return

        # ottavas -> QuindicesimaA
        desires = [Toke_QuindicesimaA]
        if self.toker.sees(desires):
            self.print('ottavas -> QuindicesimaA', end='\n')
            self.toker.burn(Toke_QuindicesimaA)
            self.print('burning: QuindicesimaA', end='\n')
            return

        # ottavas -> QuindicesimaB
        desires = [Toke_QuindicesimaB]
        if self.toker.sees(desires):
            self.print('ottavas -> QuindicesimaB', end='\n')
            self.toker.burn(Toke_QuindicesimaB)
            self.print('burning: QuindicesimaB', end='\n')
            return

        # ottavas -> Loco
        desires = [Toke_Loco]
        if self.toker.sees(desires):
            self.print('ottavas -> Loco', end='\n')
            self.toker.burn(Toke_Loco)
            self.print('burning: Loco', end='\n')
            return

        # Error State
        self.fail()

    def dynamic(self):
        # dynamic -> DynPiano
        desires = [Toke_DynPiano]
        if self.toker.sees(desires):
            self.print('dynamic -> DynPiano', end='\n')
            self.toker.burn(Toke_DynPiano)
            self.print('burning: DynPiano', end='\n')
            return

        # dynamic -> DynForte
        desires = [Toke_DynForte]
        if self.toker.sees(desires):
            self.print('dynamic -> DynForte', end='\n')
            self.toker.burn(Toke_DynForte)
            self.print('burning: DynForte', end='\n')
            return

        # dynamic -> DynSFZ
        desires = [Toke_DynSFZ]
        if self.toker.sees(desires):
            self.print('dynamic -> DynSFZ', end='\n')
            self.toker.burn(Toke_DynSFZ)
            self.print('burning: DynSFZ', end='\n')
            return

        # dynamic -> DynFP
        desires = [Toke_DynFP]
        if self.toker.sees(desires):
            self.print('dynamic -> DynFP', end='\n')
            self.toker.burn(Toke_DynFP)
            self.print('burning: DynFP', end='\n')
            return

        # Error State
        self.fail()

    def listy_suffix(self):
        # listy_suffix -> listy_entries ListE
        desires = [Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat, Toke_ListS,
                   Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown, Toke_Symbol,
                   Toke_String, Toke_DynFP, Toke_QuindicesimaB, Toke_Int, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_DynSFZ, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura, Toke_DynPiano,
                   Toke_Choard, Toke_Rep, Toke_DynForte, Toke_Loco, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('listy_suffix -> listy_entries ListE', end='\n')
            self.listy_entries()
            self.toker.burn(Toke_ListE)
            self.print('burning: ListE', end='\n')
            return

        # Error State
        self.fail()

    def optional_stmt(self):
        # optional_stmt -> stmt
        desires = [Toke_Loco, Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat,
                   Toke_ListS, Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown,
                   Toke_Symbol, Toke_String, Toke_DynFP, Toke_Carrots, Toke_Int,
                   Toke_AccFlat, Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_DynSFZ, Toke_OttavaB,
                   Toke_OttavaA, Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura,
                   Toke_DynPiano, Toke_Choard, Toke_Rep, Toke_DynForte, Toke_CurNoat,
                   Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('optional_stmt -> stmt', end='\n')
            self.stmt()
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def meteroid(self):
        # meteroid -> optional_carrots Symbol msg_chain_node
        desires = [Toke_Symbol, Toke_Carrots]
        if self.toker.sees(desires):
            self.print('meteroid -> optional_carrots Symbol msg_chain_node', end='\n')
            self.optional_carrots()
            self.toker.burn(Toke_Symbol)
            self.print('burning: Symbol', end='\n')
            self.msg_chain_node()
            return

        # meteroid -> clef
        desires = [Toke_AltoClef, Toke_BassClef, Toke_TrebleClef]
        if self.toker.sees(desires):
            self.print('meteroid -> clef', end='\n')
            self.clef()
            return

        # Error State
        self.fail()

    def meter_sig_prime(self):
        # meter_sig_prime -> Slash Int
        desires = [Toke_Slash]
        if self.toker.sees(desires):
            self.print('meter_sig_prime -> Slash Int', end='\n')
            self.toker.burn(Toke_Slash)
            self.print('burning: Slash', end='\n')
            self.toker.burn(Toke_Int)
            self.print('burning: Int', end='\n')
            return

        # Error State
        self.fail()

    def conditional(self):
        # conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE
        desires = [Toke_CondS]
        if self.toker.sees(desires):
            self.print('conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE', end='\n')
            self.toker.burn(Toke_CondS)
            self.print('burning: CondS', end='\n')
            self.optional_stmt()
            self.toker.burn(Toke_CondSep)
            self.print('burning: CondSep', end='\n')
            self.boolean()
            self.toker.burn(Toke_CondSep)
            self.print('burning: CondSep', end='\n')
            self.optional_stmt()
            self.toker.burn(Toke_CondE)
            self.print('burning: CondE', end='\n')
            return

        # Error State
        self.fail()

    def musical_keyword_misc(self):
        # musical_keyword_misc -> PedalDown
        desires = [Toke_PedalDown]
        if self.toker.sees(desires):
            self.print('musical_keyword_misc -> PedalDown', end='\n')
            self.toker.burn(Toke_PedalDown)
            self.print('burning: PedalDown', end='\n')
            return

        # musical_keyword_misc -> PedalUp
        desires = [Toke_PedalUp]
        if self.toker.sees(desires):
            self.print('musical_keyword_misc -> PedalUp', end='\n')
            self.toker.burn(Toke_PedalUp)
            self.print('burning: PedalUp', end='\n')
            return

        # musical_keyword_misc -> Rep
        desires = [Toke_Rep]
        if self.toker.sees(desires):
            self.print('musical_keyword_misc -> Rep', end='\n')
            self.toker.burn(Toke_Rep)
            self.print('burning: Rep', end='\n')
            return

        # musical_keyword_misc -> DubRep
        desires = [Toke_DubRep]
        if self.toker.sees(desires):
            self.print('musical_keyword_misc -> DubRep', end='\n')
            self.toker.burn(Toke_DubRep)
            self.print('burning: DubRep', end='\n')
            return

        # musical_keyword_misc -> Portamento
        desires = [Toke_Portamento]
        if self.toker.sees(desires):
            self.print('musical_keyword_misc -> Portamento', end='\n')
            self.toker.burn(Toke_Portamento)
            self.print('burning: Portamento', end='\n')
            return

        # Error State
        self.fail()

    def markers(self):
        # markers -> Segno
        desires = [Toke_Segno]
        if self.toker.sees(desires):
            self.print('markers -> Segno', end='\n')
            self.toker.burn(Toke_Segno)
            self.print('burning: Segno', end='\n')
            return

        # markers -> Fine
        desires = [Toke_Fine]
        if self.toker.sees(desires):
            self.print('markers -> Fine', end='\n')
            self.toker.burn(Toke_Fine)
            self.print('burning: Fine', end='\n')
            return

        # markers -> coda
        desires = [Toke_Coda]
        if self.toker.sees(desires):
            self.print('markers -> coda', end='\n')
            self.coda()
            return

        # markers -> measure_marker
        desires = [Toke_Bars]
        if self.toker.sees(desires):
            self.print('markers -> measure_marker', end='\n')
            self.measure_marker()
            return

        # Error State
        self.fail()

    def meter_ass_r(self):
        # meter_ass_r -> Symbol
        desires = [Toke_Symbol]
        if self.toker.sees(desires):
            self.print('meter_ass_r -> Symbol', end='\n')
            self.toker.burn(Toke_Symbol)
            self.print('burning: Symbol', end='\n')
            return

        # meter_ass_r -> beat
        desires = [Toke_Quarters, Toke_Eighths, Toke_Quavers, Toke_Slash, Toke_Crotchets]
        if self.toker.sees(desires):
            self.print('meter_ass_r -> beat', end='\n')
            self.beat()
            return

        # meter_ass_r -> dynamic
        desires = [Toke_DynFP, Toke_DynForte, Toke_DynSFZ, Toke_DynPiano]
        if self.toker.sees(desires):
            self.print('meter_ass_r -> dynamic', end='\n')
            self.dynamic()
            return

        # Error State
        self.fail()

    def meter(self):
        # meter -> MeterS meter_stmts MeterE
        desires = [Toke_MeterS]
        if self.toker.sees(desires):
            self.print('meter -> MeterS meter_stmts MeterE', end='\n')
            self.toker.burn(Toke_MeterS)
            self.print('burning: MeterS', end='\n')
            self.meter_stmts()
            self.toker.burn(Toke_MeterE)
            self.print('burning: MeterE', end='\n')
            return

        # Error State
        self.fail()

    def noat(self):
        # noat -> VectorNoat sharps_or_flats
        desires = [Toke_VectorNoat]
        if self.toker.sees(desires):
            self.print('noat -> VectorNoat sharps_or_flats', end='\n')
            self.toker.burn(Toke_VectorNoat)
            self.print('burning: VectorNoat', end='\n')
            self.sharps_or_flats()
            return

        # Error State
        self.fail()

    def nouny(self):
        # nouny -> cthulhu
        desires = [Toke_LWing]
        if self.toker.sees(desires):
            self.print('nouny -> cthulhu', end='\n')
            self.cthulhu()
            return

        # nouny -> noaty
        desires = [Toke_Choard, Toke_VectorNoat, Toke_ListS, Toke_CondS, Toke_Symbol,
                   Toke_CurNoat]
        if self.toker.sees(desires):
            self.print('nouny -> noaty', end='\n')
            self.noaty()
            return

        # nouny -> nouny_literal
        desires = [Toke_Tuplet, Toke_Int, Toke_Slur, Toke_Float, Toke_Caesura,
                   Toke_String]
        if self.toker.sees(desires):
            self.print('nouny -> nouny_literal', end='\n')
            self.nouny_literal()
            return

        # nouny -> accidentally
        desires = [Toke_AccSharp, Toke_AccFlat, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('nouny -> accidentally', end='\n')
            self.accidentally()
            return

        # nouny -> musical_keyword
        desires = [Toke_OttavaB, Toke_OttavaA, Toke_DynSFZ, Toke_DubRep, Toke_Portamento,
                   Toke_PedalDown, Toke_DynPiano, Toke_Rep, Toke_DynForte, Toke_Loco,
                   Toke_DynFP, Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_PedalUp]
        if self.toker.sees(desires):
            self.print('nouny -> musical_keyword', end='\n')
            self.musical_keyword()
            return

        # Error State
        self.fail()

    def cthulhu(self):
        # cthulhu -> LWing CondSep cthulhu_prime
        desires = [Toke_LWing]
        if self.toker.sees(desires):
            self.print('cthulhu -> LWing CondSep cthulhu_prime', end='\n')
            self.toker.burn(Toke_LWing)
            self.print('burning: LWing', end='\n')
            self.toker.burn(Toke_CondSep)
            self.print('burning: CondSep', end='\n')
            self.cthulhu_prime()
            return

        # Error State
        self.fail()

    def skoaroid_prime(self):
        # skoaroid_prime -> assignment skoaroid_prime
        desires = [Toke_AssOp]
        if self.toker.sees(desires):
            self.print('skoaroid_prime -> assignment skoaroid_prime', end='\n')
            self.assignment()
            self.skoaroid_prime()
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def meter_stmt_numbery(self):
        # meter_stmt_numbery -> AssOp meter_ass_r
        desires = [Toke_AssOp]
        if self.toker.sees(desires):
            self.print('meter_stmt_numbery -> AssOp meter_ass_r', end='\n')
            self.toker.burn(Toke_AssOp)
            self.print('burning: AssOp', end='\n')
            self.meter_ass_r()
            return

        # meter_stmt_numbery -> meter_sig_prime
        desires = [Toke_Slash]
        if self.toker.sees(desires):
            self.print('meter_stmt_numbery -> meter_sig_prime', end='\n')
            self.meter_sig_prime()
            return

        # Error State
        self.fail()

    def al_whatnow(self):
        # al_whatnow -> AlCoda
        desires = [Toke_AlCoda]
        if self.toker.sees(desires):
            self.print('al_whatnow -> AlCoda', end='\n')
            self.toker.burn(Toke_AlCoda)
            self.print('burning: AlCoda', end='\n')
            return

        # al_whatnow -> AlSegno
        desires = [Toke_AlSegno]
        if self.toker.sees(desires):
            self.print('al_whatnow -> AlSegno', end='\n')
            self.toker.burn(Toke_AlSegno)
            self.print('burning: AlSegno', end='\n')
            return

        # al_whatnow -> AlFine
        desires = [Toke_AlFine]
        if self.toker.sees(desires):
            self.print('al_whatnow -> AlFine', end='\n')
            self.toker.burn(Toke_AlFine)
            self.print('burning: AlFine', end='\n')
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def noaty(self):
        # noaty -> Choard
        desires = [Toke_Choard]
        if self.toker.sees(desires):
            self.print('noaty -> Choard', end='\n')
            self.toker.burn(Toke_Choard)
            self.print('burning: Choard', end='\n')
            return

        # noaty -> Symbol
        desires = [Toke_Symbol]
        if self.toker.sees(desires):
            self.print('noaty -> Symbol', end='\n')
            self.toker.burn(Toke_Symbol)
            self.print('burning: Symbol', end='\n')
            return

        # noaty -> CurNoat
        desires = [Toke_CurNoat]
        if self.toker.sees(desires):
            self.print('noaty -> CurNoat', end='\n')
            self.toker.burn(Toke_CurNoat)
            self.print('burning: CurNoat', end='\n')
            return

        # noaty -> noat
        desires = [Toke_VectorNoat]
        if self.toker.sees(desires):
            self.print('noaty -> noat', end='\n')
            self.noat()
            return

        # noaty -> listy
        desires = [Toke_ListS]
        if self.toker.sees(desires):
            self.print('noaty -> listy', end='\n')
            self.listy()
            return

        # noaty -> conditional
        desires = [Toke_CondS]
        if self.toker.sees(desires):
            self.print('noaty -> conditional', end='\n')
            self.conditional()
            return

        # Error State
        self.fail()

    def acc(self):
        # acc -> AccSharp
        desires = [Toke_AccSharp]
        if self.toker.sees(desires):
            self.print('acc -> AccSharp', end='\n')
            self.toker.burn(Toke_AccSharp)
            self.print('burning: AccSharp', end='\n')
            return

        # acc -> AccNatural
        desires = [Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('acc -> AccNatural', end='\n')
            self.toker.burn(Toke_AccNatural)
            self.print('burning: AccNatural', end='\n')
            return

        # acc -> AccFlat
        desires = [Toke_AccFlat]
        if self.toker.sees(desires):
            self.print('acc -> AccFlat', end='\n')
            self.toker.burn(Toke_AccFlat)
            self.print('burning: AccFlat', end='\n')
            return

        # Error State
        self.fail()

    def meter_stmt(self):
        # meter_stmt -> Int meter_stmt_numbery
        desires = [Toke_Int]
        if self.toker.sees(desires):
            self.print('meter_stmt -> Int meter_stmt_numbery', end='\n')
            self.toker.burn(Toke_Int)
            self.print('burning: Int', end='\n')
            self.meter_stmt_numbery()
            return

        # meter_stmt -> meteroid
        desires = [Toke_AltoClef, Toke_BassClef, Toke_Symbol, Toke_Carrots, Toke_TrebleClef]
        if self.toker.sees(desires):
            self.print('meter_stmt -> meteroid', end='\n')
            self.meteroid()
            return

        # Error State
        self.fail()

    def optional_carrots(self):
        # optional_carrots -> Carrots
        desires = [Toke_Carrots]
        if self.toker.sees(desires):
            self.print('optional_carrots -> Carrots', end='\n')
            self.toker.burn(Toke_Carrots)
            self.print('burning: Carrots', end='\n')
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def beat(self):
        # beat -> Crotchets
        desires = [Toke_Crotchets]
        if self.toker.sees(desires):
            self.print('beat -> Crotchets', end='\n')
            self.toker.burn(Toke_Crotchets)
            self.print('burning: Crotchets', end='\n')
            return

        # beat -> Quavers
        desires = [Toke_Quavers]
        if self.toker.sees(desires):
            self.print('beat -> Quavers', end='\n')
            self.toker.burn(Toke_Quavers)
            self.print('burning: Quavers', end='\n')
            return

        # beat -> Quarters
        desires = [Toke_Quarters]
        if self.toker.sees(desires):
            self.print('beat -> Quarters', end='\n')
            self.toker.burn(Toke_Quarters)
            self.print('burning: Quarters', end='\n')
            return

        # beat -> Eighths
        desires = [Toke_Eighths]
        if self.toker.sees(desires):
            self.print('beat -> Eighths', end='\n')
            self.toker.burn(Toke_Eighths)
            self.print('burning: Eighths', end='\n')
            return

        # beat -> Slash
        desires = [Toke_Slash]
        if self.toker.sees(desires):
            self.print('beat -> Slash', end='\n')
            self.toker.burn(Toke_Slash)
            self.print('burning: Slash', end='\n')
            return

        # Error State
        self.fail()

    def skoar(self):
        # skoar -> phrases
        desires = [Toke_Tuplet, Toke_Eighths, Toke_PedalUp, Toke_DaCapo, Toke_AccSharp,
                   Toke_Coda, Toke_String, Toke_Quavers, Toke_CurNoat, Toke_DubRep,
                   Toke_Quarters, Toke_Float, Toke_ListS, Toke_Bars, Toke_Rep,
                   Toke_Loco, Toke_AccNatural, Toke_Fine, Toke_LWing, Toke_DynSFZ,
                   Toke_VectorNoat, Toke_Comment, Toke_PedalDown, Toke_CondS, Toke_Symbol,
                   Toke_DynFP, Toke_EOF, Toke_Int, Toke_Portamento, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_Crotchets, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slash, Toke_Caesura, Toke_DynPiano, Toke_DalSegno, Toke_Choard,
                   Toke_DynForte, Toke_Slur, Toke_Segno, Toke_MeterS]
        if self.toker.sees(desires):
            self.print('skoar -> phrases', end='\n')
            self.phrases()
            return

        # Error State
        self.fail()

    def coda(self):
        # coda -> Coda optional_al_coda
        desires = [Toke_Coda]
        if self.toker.sees(desires):
            self.print('coda -> Coda optional_al_coda', end='\n')
            self.toker.burn(Toke_Coda)
            self.print('burning: Coda', end='\n')
            self.optional_al_coda()
            return

        # Error State
        self.fail()

    def sharps_or_flats(self):
        # sharps_or_flats -> NoatSharps
        desires = [Toke_NoatSharps]
        if self.toker.sees(desires):
            self.print('sharps_or_flats -> NoatSharps', end='\n')
            self.toker.burn(Toke_NoatSharps)
            self.print('burning: NoatSharps', end='\n')
            return

        # sharps_or_flats -> NoatFlats
        desires = [Toke_NoatFlats]
        if self.toker.sees(desires):
            self.print('sharps_or_flats -> NoatFlats', end='\n')
            self.toker.burn(Toke_NoatFlats)
            self.print('burning: NoatFlats', end='\n')
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def stmt(self):
        # stmt -> optional_carrots skoaroid msg_chain_node
        desires = [Toke_Loco, Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat,
                   Toke_ListS, Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown,
                   Toke_Symbol, Toke_String, Toke_DynFP, Toke_Int, Toke_CurNoat,
                   Toke_AccFlat, Toke_QuindicesimaA, Toke_Carrots, Toke_DynSFZ, Toke_OttavaB,
                   Toke_OttavaA, Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura,
                   Toke_DynPiano, Toke_Choard, Toke_Rep, Toke_DynForte, Toke_QuindicesimaB,
                   Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('stmt -> optional_carrots skoaroid msg_chain_node', end='\n')
            self.optional_carrots()
            self.skoaroid()
            self.msg_chain_node()
            return

        # Error State
        self.fail()

    def boolean(self):
        # boolean -> skoaroid BooleanOp skoaroid
        desires = [Toke_Loco, Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat,
                   Toke_ListS, Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown,
                   Toke_Symbol, Toke_String, Toke_DynFP, Toke_Int, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_DynSFZ, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura, Toke_DynPiano,
                   Toke_Choard, Toke_Rep, Toke_DynForte, Toke_CurNoat, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('boolean -> skoaroid BooleanOp skoaroid', end='\n')
            self.skoaroid()
            self.toker.burn(Toke_BooleanOp)
            self.print('burning: BooleanOp', end='\n')
            self.skoaroid()
            return

        # Error State
        self.fail()

    def meter_stmts(self):
        # meter_stmts -> meter_stmt meter_stmts
        desires = [Toke_Int, Toke_BassClef, Toke_AltoClef, Toke_Symbol, Toke_Carrots,
                   Toke_TrebleClef]
        if self.toker.sees(desires):
            self.print('meter_stmts -> meter_stmt meter_stmts', end='\n')
            self.meter_stmt()
            self.meter_stmts()
            return

        # <e>
        self.print('burning empty', end='\n')
        return

    def listy_entries(self):
        # listy_entries -> skoaroid moar_listy_entries
        desires = [Toke_Loco, Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat,
                   Toke_ListS, Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown,
                   Toke_Symbol, Toke_String, Toke_DynFP, Toke_Int, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_DynSFZ, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura, Toke_DynPiano,
                   Toke_Choard, Toke_Rep, Toke_DynForte, Toke_CurNoat, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('listy_entries -> skoaroid moar_listy_entries', end='\n')
            self.skoaroid()
            self.moar_listy_entries()
            return

        # Error State
        self.fail()

    def cthulhu_prime(self):
        # cthulhu_prime -> boolean CondSep RWing
        desires = [Toke_LWing, Toke_Tuplet, Toke_PedalUp, Toke_VectorNoat, Toke_ListS,
                   Toke_Portamento, Toke_AccSharp, Toke_CondS, Toke_PedalDown, Toke_Symbol,
                   Toke_String, Toke_DynFP, Toke_QuindicesimaB, Toke_Int, Toke_AccFlat,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_DynSFZ, Toke_OttavaB, Toke_OttavaA,
                   Toke_Slur, Toke_DubRep, Toke_Float, Toke_Caesura, Toke_DynPiano,
                   Toke_Choard, Toke_Rep, Toke_DynForte, Toke_Loco, Toke_AccNatural]
        if self.toker.sees(desires):
            self.print('cthulhu_prime -> boolean CondSep RWing', end='\n')
            self.boolean()
            self.toker.burn(Toke_CondSep)
            self.print('burning: CondSep', end='\n')
            self.toker.burn(Toke_RWing)
            self.print('burning: RWing', end='\n')
            return

        # cthulhu_prime -> Nosey CondSep RWing
        desires = [Toke_Nosey]
        if self.toker.sees(desires):
            self.print('cthulhu_prime -> Nosey CondSep RWing', end='\n')
            self.toker.burn(Toke_Nosey)
            self.print('burning: Nosey', end='\n')
            self.toker.burn(Toke_CondSep)
            self.print('burning: CondSep', end='\n')
            self.toker.burn(Toke_RWing)
            self.print('burning: RWing', end='\n')
            return

        # Error State
        self.fail()

    def assignment(self):
        # assignment -> AssOp settable
        desires = [Toke_AssOp]
        if self.toker.sees(desires):
            self.print('assignment -> AssOp settable', end='\n')
            self.toker.burn(Toke_AssOp)
            self.print('burning: AssOp', end='\n')
            self.settable()
            return

        # Error State
        self.fail()

