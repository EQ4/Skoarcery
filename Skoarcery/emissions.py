from datetime import datetime
import sys
import abc


class Tabby:

    def __init__(self):
        self.tab = 0

    def __iadd__(self, other):
        self.tab += other
        return self

    def __isub__(self, other):
        self.tab -= other
        if self.tab < 0:
            raise AssertionError("Tried to decrement tabby past 0")
        return self

    def __mul__(self, other):
        return self.tab * other

    def __rmul__(self, other):
        return self.tab * other

    def __eq__(self, other):
        return self.tab == other


class Tongue:

    __metaclass__ = abc.ABCMeta

    def __init__(self):
        self.tab = Tabby()
        self.ptab = 0
        self.fd = sys.stdout

    # ----------
    # properties
    # ----------
    @abc.abstractproperty
    def cmt_char(self):
        raise NotImplementedError

    @abc.abstractproperty
    def language(self):
        raise NotImplementedError

    @abc.abstractproperty
    def ext(self):
        raise NotImplementedError

    @abc.abstractproperty
    def this(self):
        raise NotImplementedError

    @abc.abstractproperty
    def null(self):
        raise NotImplementedError

    @abc.abstractproperty
    def true(self):
        raise NotImplementedError

    @abc.abstractproperty
    def false(self):
        raise NotImplementedError

    @property
    def tabby(self):
        if self.tab == 0:
            return ""

        return ("{:>" + str(self.tab * 4) + "}").format(" ")

    # -------
    # methods
    # -------
    @abc.abstractmethod
    def stmt(self, line, end="\n"):
        raise NotImplementedError

    @abc.abstractmethod
    def abstract_class(self, name, extends=None):
        raise NotImplementedError

    @abc.abstractmethod
    def class_(self, name, extends=None):
        raise NotImplementedError

    @abc.abstractmethod
    def classvar(self, prefix, name, value=None):
        raise NotImplementedError

    @abc.abstractmethod
    def attrvar(self, prefix, name, value=None):
        raise NotImplementedError

    @abc.abstractmethod
    def var(self, name, value=None):
        raise NotImplementedError

    @abc.abstractmethod
    def expand_args(self, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def constructor(self, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def function(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def method(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def static_method(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def abstract_static_method(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def if_(self, condition):
        raise NotImplementedError

    @abc.abstractmethod
    def end_if(self):
        raise NotImplementedError

    @abc.abstractmethod
    def end_block(self):
        raise NotImplementedError

    @abc.abstractmethod
    def return_(self, value=""):
        raise NotImplementedError

    @abc.abstractmethod
    def throw(self, name, msg):
        raise NotImplementedError

    @abc.abstractmethod
    def find_regex(self, match, regex, buf, offs):
        raise NotImplementedError

    @abc.abstractmethod
    def v_regex_group_zero(self, match):
        raise NotImplementedError

    @abc.abstractmethod
    def v_length(self, x):
        raise NotImplementedError

    @abc.abstractmethod
    def v_new(self, cls, *args):
        raise NotImplementedError

    @abc.abstractmethod
    def v_attr(self, attr):
        raise NotImplementedError

    @abc.abstractmethod
    def v_def_regex(self, regex):
        raise NotImplementedError

    @abc.abstractmethod
    def v_match(self, match):
        raise NotImplementedError

    def v_str(self, s):
        return '"' + s + '"'

    def raw(self, code):
        self._emit(code, end="")

    def file_header(self, filename, spell):
        self.cmt(box("{filename}{ext} - Generated by {spell} on {date} for {language}".format(
            filename=filename, ext=self.ext, spell=spell,
            date=str(datetime.now()).split(".")[0],
            language=self.language), "="))

    def cmt(self, words):
        pref = self.tabby + self.cmt_char + " "
        x = "\n" + pref
        words = pref + words.replace("\n", x)
        self._emit(words, end="\n")

    def cmt_hdr(self, text):
        self.cmt(box(text))

    def newline(self, n=1):
        for i in range(0, n):
            self._emit("", end="\n")

    def _emit(self, text, end=""):
        print(text, end=end, file=self.fd)

        if self.fd != sys.stdout:
            print(text, end=end)


class PyTongue(Tongue):

    def __init__(self):
        super().__init__()

    @property
    def cmt_char(self):
        return "#"

    @property
    def language(self):
        return "Python 3.3.2"

    @property
    def ext(self):
        return ".py"

    @property
    def this(self):
        return "self"

    @property
    def null(self):
        return "None"

    @property
    def false(self):
        return "False"

    @property
    def true(self):
        return "True"

    def stmt(self, line, end="\n"):
        self._emit(self.tabby + line, end=end)

    def if_(self, condition):
        self.stmt("if " + condition + ":")
        self.tab += 1

    def return_(self, value=""):
        self.stmt("return " + value)

    def end_if(self):
        self.end_block()

    def end_block(self):
        self.tab -= 1
        self.newline()

    def expand_args(self, *args, **kwargs):
        a = ""
        for arg in args:
            if a != "":
                a += ", "
            a += arg

        for k, v in kwargs.items():
            if a != "":
                a += ", "
            a += k + "=" + v

        return a

    def constructor(self, *args, **kwargs):
        self.function("__init__", "self", *args, **kwargs)

    def function(self, name, *args, **kwargs):
        s = "def " + name + "("
        s += self.expand_args(*args, **kwargs) + "):"
        self.stmt(s)
        self.tab += 1

    def abstract_class(self, name, extends=None):
        self.class_(name, extends)
        self.stmt("__metaclass__ = abc.ABCMeta")

    def class_(self, name, extends=None):
        s = "class " + name
        if extends:
            s += "(" + extends + ")"
        s += ":"
        self.stmt(s)
        self.tab += 1

    def classvar(self, prefix, name, value=None):
        s = name
        if value:
            s += " = " + value
        self.stmt(s)

    def attrvar(self, prefix, name, value=None):
        pass

    def var(self, name, value=None):
        s = name
        if value:
            s += " = " + value
        self.stmt(s)

    def method(self, name, *args, **kwargs):
        self.function(name, "self", *args, **kwargs)

    def throw(self, name, msg):
        self.stmt("raise " + name + "(" + msg + ")")

    def abstract_static_method(self, name, *args, **kwargs):
        self.stmt("@staticmethod")
        self.stmt("@abc.abstractstaticmethod")
        self.function(name, *args, **kwargs)

    def static_method(self, name, *args, **kwargs):
        self.stmt("@staticmethod")
        self.function(name, *args, **kwargs)

    def find_regex(self, match, regex, buf, offs):
        self.stmt(match + " = " + regex + ".match(" + buf + ", " + offs + ")")

    def v_regex_group_zero(self, match):
        return match + ".group(0)"

    def v_new(self, cls, *args):
        a = self.expand_args(*args)
        return cls + "(" + a + ")"

    def v_ass(self, dst, src):
        return dst + " = " + src

    def v_length(self, x):
        return "len(" + x + ")"

    def v_attr(self, attr):
        return "self." + attr

    def v_def_regex(self, regex):
        return 're.compile(r"' + regex + '")'

    def v_match(self, match):
        return match


class ScTongue(Tongue):

    def __init__(self):
        super().__init__()

    @property
    def cmt_char(self):
        return "//"

    @property
    def language(self):
        return "SuperCollider 3.6"

    @property
    def ext(self):
        return ".sc"

    @property
    def this(self):
        return "this"

    @property
    def null(self):
        return "nil"

    @property
    def true(self):
        return "true"

    @property
    def false(self):
        return "false"

    def stmt(self, line, end=";\n"):
        self._emit(self.tabby + line, end=end)

    def if_(self, condition):
        self.stmt("if (" + condition + ") {", end="\n")
        self.tab += 1

    def end_if(self):
        self.tab -= 1
        self.stmt("}")
        self.newline()

    def end_block(self):
        self.tab -= 1
        self.stmt("}", end="\n")
        self.newline()

    def return_(self, value=""):
        self.stmt("^" + value)

    def function(self, name, *args, **kwargs):
        self.stmt(name + " {", end="\n")
        self.tab += 1

        a = self.expand_args(*args, **kwargs)
        if a != "":
            self.stmt("| " + a + " |", end="\n")
            self.newline()

    def abstract_static_method(self, name, *args, **kwargs):
        self.static_method(name, *args, **kwargs)

    def method(self, name, *args, **kwargs):
        self.function(name, *args, **kwargs)

    def static_method(self, name, *args, **kwargs):
        name = "*" + name
        self.function(name, *args, **kwargs)

    def constructor(self, *args, **kwargs):
        a = self.expand_args_just_keys(*args, **kwargs)

        self.static_method("new", *args, **kwargs)
        self.return_("super.new.init( " + a + " )")
        self.end_block()

        self.function("init", *args, **kwargs)

    def abstract_class(self, name, extends=None):
        self.class_(name, extends)

    def class_(self, name, extends=None):
        s = name
        if extends:
            s += " : " + extends
        s += " {"
        self.stmt(s, end="\n")
        self.tab += 1

    def classvar(self, prefix, name, value=None):
        s = prefix + name
        if value is not None:
            s += " = " + value

        self.stmt("classvar " + s)

    def attrvar(self, prefix, name, value=None):
        self.stmt("var " + prefix + name)

    def var(self, name, value=None):
        s = name
        if value is not None:
            s += " = " + value
        self.stmt("var " + s)

    def throw(self, name, msg):
        self.stmt(name + "(" + msg + ").throw")

    def find_regex(self, match, regex, buf, offs):
        self.stmt("var " + match + " = " + buf + ".findRegexp(" + regex + ", " + offs + ")")

    def v_ass(self, dst, src):
        return dst + " = " + src

    def v_regex_group_zero(self, match):
        return match + "[0][1]"

    def v_new(self, cls, *args):
        a = self.expand_args(*args)
        return cls + ".new(" + a + ")"

    def v_length(self, x):
        return x + ".size"

    def v_attr(self, attr):
        return attr

    def v_def_regex(self, regex):
        return '"' + regex + '"'

    def v_match(self, match):
        return self.v_length(match) + " > 0"

    def expand_args(self, *args, **kwargs):
        a = ""
        for arg in args:
            if a != "":
                a += ", "
            a += arg

        for k, v in kwargs.items():
            if a != "":
                a += ", "
            a += k + "=" + v

        return a

    def expand_args_just_keys(self, *args, **kwargs):
        a = ""
        for arg in args:
            if a != "":
                a += ", "
            a += arg

        for k, v in kwargs.items():
            if a != "":
                a += ", "
            a += k + "=" + v

        return a


def box(text, char="-"):
    n = len(text)

    line = ("{:" + char + ">" + str(n) + "}").format(char)

    return "{line}\n{text}\n{line}".format(line=line, text=text)

SC = None
PY = None
tongues = []


def init():
    global SC, PY, tongues

    SC = ScTongue()
    PY = PyTongue()

    tongues = [SC, PY]
