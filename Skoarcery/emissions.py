from datetime import datetime
import sys
import abc


class Tabby:

    def __init__(self):
        self.tab = 0

    def __iadd__(self, other):
        self.tab += other
        return self

    def __isub__(self, other):
        self.tab -= other
        if self.tab < 0:
            raise AssertionError("Tried to decrement tabby past 0")
        return self

    def __mul__(self, other):
        return self.tab * other

    def __rmul__(self, other):
        return self.tab * other

    def __eq__(self, other):
        return self.tab == other


class Tongue:

    __metaclass__ = abc.ABCMeta

    def __init__(self):
        self.tab = Tabby()
        self.ptab = 0
        self.fd = sys.stdout

    # ----------
    # properties
    # ----------
    @abc.abstractproperty
    def cmt_char(self):
        raise NotImplementedError

    @abc.abstractproperty
    def language(self):
        raise NotImplementedError

    @abc.abstractproperty
    def ext(self):
        raise NotImplementedError

    @abc.abstractproperty
    def this(self):
        raise NotImplementedError

    @abc.abstractproperty
    def null(self):
        raise NotImplementedError

    @abc.abstractproperty
    def true(self):
        raise NotImplementedError

    @abc.abstractproperty
    def false(self):
        raise NotImplementedError

    @property
    def tabby(self):
        if self.tab == 0:
            return ""

        return ("{:>" + str(self.tab * 4) + "}").format(" ")

    # -------
    # methods
    # -------
    @abc.abstractmethod
    def code_line(self, line, end="\n"):
        raise NotImplementedError

    @abc.abstractmethod
    def _abstract_class(self, name, extends=None):
        raise NotImplementedError

    @abc.abstractmethod
    def _class(self, name, extends=None):
        raise NotImplementedError

    @abc.abstractmethod
    def _classvar(self, prefix, name, value=None):
        raise NotImplementedError

    @abc.abstractmethod
    def _var(self, prefix, name):
        raise NotImplementedError

    @abc.abstractmethod
    def expand_args(self, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def _constructor(self, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def _function(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def _method(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def _static_method(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def _abstract_static_method(self, name, *args, **kwargs):
        raise NotImplementedError

    @abc.abstractmethod
    def _if(self, condition):
        raise NotImplementedError

    @abc.abstractmethod
    def _end_if(self):
        raise NotImplementedError

    @abc.abstractmethod
    def _end_block(self):
        raise NotImplementedError

    @abc.abstractmethod
    def _return(self, value=""):
        raise NotImplementedError

    @abc.abstractmethod
    def _exception(self, name, msg):
        raise NotImplementedError

    @abc.abstractmethod
    def length(self, x):
        raise NotImplementedError

    def raw(self, code):
        self.emit(code, end="")

    def _file_header(self, filename, spell):
        self._cmt(box("{filename}{ext} - Generated by {spell} on {date} for {language}".format(
            filename=filename, ext=self.ext, spell=spell,
            date=str(datetime.now()).split(".")[0],
            language=self.language), "="))

    def _cmt(self, words):
        pref = self.tabby + self.cmt_char + " "
        x = "\n" + pref
        words = pref + words.replace("\n", x)
        self.emit(words, end="\n")

    def _wee_header(self, text):
        self._cmt(box(text))

    def _newline(self, n=1):
        for i in range(0, n):
            self.emit("", end="\n")

    def emit(self, text, end=""):
        print(text, end=end, file=self.fd)

        if self.fd != sys.stdout:
            print(text, end=end)


class PyTongue(Tongue):

    def __init__(self):
        super().__init__()

    @property
    def cmt_char(self):
        return "#"

    @property
    def language(self):
        return "Python 3.3.2"

    @property
    def ext(self):
        return ".py"

    @property
    def this(self):
        return "self"

    @property
    def null(self):
        return "None"

    @property
    def false(self):
        return "False"

    @property
    def true(self):
        return "True"

    def code_line(self, line, end="\n"):
        self.emit(self.tabby + line, end=end)

    def _if(self, condition):
        self.code_line("if " + condition + ":")
        self.tab += 1
        self.code_line("I.tab += 1")

    def _return(self, value=""):
        self.code_line("I.tab -= 1")
        self.code_line("return " + value)

    def _end_if(self):
        self._end_block()

    def _end_block(self):
        self.tab -= 1
        self._newline()

    def print(self, line, end="\n"):
        self.code_line("I.print('" + line + "', end=" + repr(end) + ")")

    def expand_args(self, *args, **kwargs):
        a = ""
        for arg in args:
            if a != "":
                a += ", "
            a += arg

        for k, v in kwargs.items():
            if a != "":
                a += ", "
            a += k + "=" + v

        return a

    def _constructor(self, *args, **kwargs):
        self._function("__init__", "self", *args, **kwargs)

    def _function(self, name, *args, **kwargs):
        s = "def " + name + "("
        s += self.expand_args(*args, **kwargs) + "):"
        self.code_line(s)
        self.tab += 1

    def _abstract_class(self, name, extends=None):
        self._class(name, extends)
        self.code_line("__metaclass__ = abc.ABCMeta")

    def _class(self, name, extends=None):
        s = "class " + name
        if extends:
            s += "(" + extends + ")"
        s += ":"
        self.code_line(s)
        self.tab += 1

    def _classvar(self, prefix, name, value=None):
        self.code_line(name + " = " + value)

    def _var(self, prefix, name):
        pass

    def _method(self, name, *args, **kwargs):
        self._function(name, "self", *args, **kwargs)

    def _exception(self, name, msg):
        self.code_line("raise " + name + "(" + msg + ")")

    def _abstract_static_method(self, name, *args, **kwargs):
        self.code_line("@abc.abstractstaticmethod")
        self._static_method(name, *args, **kwargs)

    def _static_method(self, name, *args, **kwargs):
        self.code_line("@staticmethod")
        self._method(name, *args, **kwargs)

    def length(self, x):
        return "len(" + x + ")"


class ScTongue(Tongue):

    def __init__(self):
        super().__init__()

    @property
    def cmt_char(self):
        return "//"

    @property
    def language(self):
        return "SuperCollider 3.6"

    @property
    def ext(self):
        return ".sc"

    @property
    def this(self):
        return "this"

    @property
    def null(self):
        return "nil"

    @property
    def true(self):
        return "true"

    @property
    def false(self):
        return "false"

    def code_line(self, line, end=";\n"):
        self.emit(self.tabby + line, end=end)

    def _if(self, condition):
        self.code_line("if (" + condition + ") {", end="\n")
        self.tab += 1

    def _end_if(self):
        self.tab -= 1
        self.code_line("}")
        self._newline()

    def _end_block(self):
        self.tab -= 1
        self.code_line("}", end="\n")
        self._newline()

    def _return(self, value=""):
        self.code_line("^" + value)

    def _function(self, name, *args, **kwargs):
        self.code_line(name + " {", end="\n")
        self.tab += 1

        a = self.expand_args(*args, **kwargs)
        if a != "":
            self.code_line("| " + a + " |", end="\n")
            self._newline()

    def _abstract_static_method(self, name, *args, **kwargs):
        self._static_method(name, *args, **kwargs)

    def _method(self, name, *args, **kwargs):
        self._function(name, *args, **kwargs)

    def _static_method(self, name, *args, **kwargs):
        name = "*" + name
        self._function(name, *args, **kwargs)

    def _constructor(self, *args, **kwargs):
        a = self.expand_args_just_keys(*args, **kwargs)

        self._static_method("new", *args, **kwargs)
        self._return("super.new.init( " + a + " )")
        self._end_block()

        self._function("init", *args, **kwargs)

    def _abstract_class(self, name, extends=None):
        self._class(name, extends)

    def _class(self, name, extends=None):
        s = name
        if extends:
            s += " : " + extends
        s += " {"
        self.code_line(s, end="\n")
        self.tab += 1

    def _classvar(self, prefix, name, value=None):
        s = prefix + name
        if value is not None:
            s += " = " + value

        self.code_line("classvar " + s)

    def _var(self, prefix, name):
        self.code_line("var " + prefix + name)

    def _exception(self, name, msg):
        self.code_line(name + "(" + msg + ").throw")

    def length(self, x):
        return x + ".size"

    def expand_args(self, *args, **kwargs):
        a = ""
        for arg in args:
            if a != "":
                a += ", "
            a += arg

        for k, v in kwargs.items():
            if a != "":
                a += ", "
            a += k + "=" + v

        return a

    def expand_args_just_keys(self, *args, **kwargs):
        a = ""
        for arg in args:
            if a != "":
                a += ", "
            a += arg

        for k, v in kwargs.items():
            if a != "":
                a += ", "
            a += k + "=" + v

        return a


def box(text, char="-"):
    n = len(text)

    line = ("{:" + char + ">" + str(n) + "}").format(char)

    return "{line}\n{text}\n{line}".format(line=line, text=text)

SC = None
PY = None


def init():
    global SC, PY
    SC = ScTongue()
    PY = PyTongue()
