// ==================================================================================================================================
// rdpp.sc.sc - Generated by Code_Parser_Sc - Create Recursive Descent Predictive Parser on 2014-05-18 01:58:54 for SuperCollider 3.6
// ==================================================================================================================================

SkoarParseException : Exception {

}

SkoarParser {

    var <runtime, <toker, <tab;

    *new {
        | runtime |
        ^super.new.init( runtime )
    }

    init {
        | runtime |

        runtime = runtime;
        toker = runtime.toker;
        tab = 0;
    }

    fail {
        toker.dump;
        SkoarParseException("Fail").throw;
    }

    //print {
    //    | line, end |
    //    (line ++ end).postln;
    //}

    musical_keyword_misc {
        | parent |

        var noad = SkoarNoad.new("musical_keyword_misc", nil, parent);
        var desires = nil;

        // musical_keyword_misc -> Rep
        desires = [Toke_Rep];
        if (toker.sees(desires) != nil) {
            "musical_keyword_misc -> Rep
".post;
            noad.add_toke("Toke_Rep", toker.burn(Toke_Rep));
            ^noad;
        };

        // musical_keyword_misc -> DubRep
        desires = [Toke_DubRep];
        if (toker.sees(desires) != nil) {
            "musical_keyword_misc -> DubRep
".post;
            noad.add_toke("Toke_DubRep", toker.burn(Toke_DubRep));
            ^noad;
        };

        // musical_keyword_misc -> Portamento
        desires = [Toke_Portamento];
        if (toker.sees(desires) != nil) {
            "musical_keyword_misc -> Portamento
".post;
            noad.add_toke("Toke_Portamento", toker.burn(Toke_Portamento));
            ^noad;
        };

        // Error State
        this.fail;
    }

    coda {
        | parent |

        var noad = SkoarNoad.new("coda", nil, parent);
        var desires = nil;

        // coda -> Coda optional_al_coda
        desires = [Toke_Coda];
        if (toker.sees(desires) != nil) {
            "coda -> Coda optional_al_coda
".post;
            noad.add_toke("Toke_Coda", toker.burn(Toke_Coda));
            noad.add_noad(this.optional_al_coda(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    settable {
        | parent |

        var noad = SkoarNoad.new("settable", nil, parent);
        var desires = nil;

        // settable -> Caesura
        desires = [Toke_Caesura];
        if (toker.sees(desires) != nil) {
            "settable -> Caesura
".post;
            noad.add_toke("Toke_Caesura", toker.burn(Toke_Caesura));
            ^noad;
        };

        // settable -> CurNoat
        desires = [Toke_CurNoat];
        if (toker.sees(desires) != nil) {
            "settable -> CurNoat
".post;
            noad.add_toke("Toke_CurNoat", toker.burn(Toke_CurNoat));
            ^noad;
        };

        // settable -> Symbol
        desires = [Toke_Symbol];
        if (toker.sees(desires) != nil) {
            "settable -> Symbol
".post;
            noad.add_toke("Toke_Symbol", toker.burn(Toke_Symbol));
            ^noad;
        };

        // settable -> listy
        desires = [Toke_ListS];
        if (toker.sees(desires) != nil) {
            "settable -> listy
".post;
            noad.add_noad(this.listy(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    noat_literal {
        | parent |

        var noad = SkoarNoad.new("noat_literal", nil, parent);
        var desires = nil;

        // noat_literal -> Choard
        desires = [Toke_Choard];
        if (toker.sees(desires) != nil) {
            "noat_literal -> Choard
".post;
            noad.add_toke("Toke_Choard", toker.burn(Toke_Choard));
            ^noad;
        };

        // noat_literal -> VectorNoat
        desires = [Toke_VectorNoat];
        if (toker.sees(desires) != nil) {
            "noat_literal -> VectorNoat
".post;
            noad.add_toke("Toke_VectorNoat", toker.burn(Toke_VectorNoat));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_ass {
        | parent |

        var noad = SkoarNoad.new("meter_ass", nil, parent);
        var desires = nil;

        // meter_ass -> AssOp meter_ass_r
        desires = [Toke_AssOp];
        if (toker.sees(desires) != nil) {
            "meter_ass -> AssOp meter_ass_r
".post;
            noad.add_toke("Toke_AssOp", toker.burn(Toke_AssOp));
            this.meter_ass_r(noad);
            ^noad;
        };

        // Error State
        this.fail;
    }

    msg_chain_node {
        | parent |

        var noad = SkoarNoad.new("msg_chain_node", nil, parent);
        var desires = nil;

        // msg_chain_node -> optional_soak MsgOp msg msg_chain_node
        desires = [Toke_Soak, Toke_MsgOp];
        if (toker.sees(desires) != nil) {
            "msg_chain_node -> optional_soak MsgOp msg msg_chain_node
".post;
            noad.add_noad(this.optional_soak(noad));
            noad.add_toke("Toke_MsgOp", toker.burn(Toke_MsgOp));
            noad.add_noad(this.msg(noad));
            noad.add_noad(this.msg_chain_node(noad));
            ^noad;
        };

        // <e>
        ^noad;
    }

    assignment {
        | parent |

        var noad = SkoarNoad.new("assignment", nil, parent);
        var desires = nil;

        // assignment -> AssOp settable
        desires = [Toke_AssOp];
        if (toker.sees(desires) != nil) {
            "assignment -> AssOp settable
".post;
            noad.add_toke("Toke_AssOp", toker.burn(Toke_AssOp));
            noad.add_noad(this.settable(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    ottavas {
        | parent |

        var noad = SkoarNoad.new("ottavas", nil, parent);
        var desires = nil;

        // ottavas -> OttavaA
        desires = [Toke_OttavaA];
        if (toker.sees(desires) != nil) {
            "ottavas -> OttavaA
".post;
            noad.add_toke("Toke_OttavaA", toker.burn(Toke_OttavaA));
            ^noad;
        };

        // ottavas -> OttavaB
        desires = [Toke_OttavaB];
        if (toker.sees(desires) != nil) {
            "ottavas -> OttavaB
".post;
            noad.add_toke("Toke_OttavaB", toker.burn(Toke_OttavaB));
            ^noad;
        };

        // ottavas -> QuindicesimaA
        desires = [Toke_QuindicesimaA];
        if (toker.sees(desires) != nil) {
            "ottavas -> QuindicesimaA
".post;
            noad.add_toke("Toke_QuindicesimaA", toker.burn(Toke_QuindicesimaA));
            ^noad;
        };

        // ottavas -> QuindicesimaB
        desires = [Toke_QuindicesimaB];
        if (toker.sees(desires) != nil) {
            "ottavas -> QuindicesimaB
".post;
            noad.add_toke("Toke_QuindicesimaB", toker.burn(Toke_QuindicesimaB));
            ^noad;
        };

        // ottavas -> Loco
        desires = [Toke_Loco];
        if (toker.sees(desires) != nil) {
            "ottavas -> Loco
".post;
            noad.add_toke("Toke_Loco", toker.burn(Toke_Loco));
            ^noad;
        };

        // Error State
        this.fail;
    }

    noaty {
        | parent |

        var noad = SkoarNoad.new("noaty", nil, parent);
        var desires = nil;

        // noaty -> noat_literal
        desires = [Toke_Choard, Toke_VectorNoat];
        if (toker.sees(desires) != nil) {
            "noaty -> noat_literal
".post;
            noad.add_noad(this.noat_literal(noad));
            ^noad;
        };

        // noaty -> noat_reference
        desires = [Toke_ListS, Toke_Symbol, Toke_CurNoat];
        if (toker.sees(desires) != nil) {
            "noaty -> noat_reference
".post;
            noad.add_noad(this.noat_reference(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    nouny_literal {
        | parent |

        var noad = parent;
        var desires = nil;

        // nouny_literal -> Tuplet
        desires = [Toke_Tuplet];
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Tuplet
".post;
            noad.add_toke("Toke_Tuplet", toker.burn(Toke_Tuplet));
            ^noad;
        };

        // nouny_literal -> Caesura
        desires = [Toke_Caesura];
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Caesura
".post;
            noad.add_toke("Toke_Caesura", toker.burn(Toke_Caesura));
            ^noad;
        };

        // nouny_literal -> Slur
        desires = [Toke_Slur];
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Slur
".post;
            noad.add_toke("Toke_Slur", toker.burn(Toke_Slur));
            ^noad;
        };

        // nouny_literal -> Int
        desires = [Toke_Int];
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Int
".post;
            noad.add_toke("Toke_Int", toker.burn(Toke_Int));
            ^noad;
        };

        // nouny_literal -> Float
        desires = [Toke_Float];
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Float
".post;
            noad.add_toke("Toke_Float", toker.burn(Toke_Float));
            ^noad;
        };

        // nouny_literal -> String
        desires = [Toke_String];
        if (toker.sees(desires) != nil) {
            "nouny_literal -> String
".post;
            noad.add_toke("Toke_String", toker.burn(Toke_String));
            ^noad;
        };

        // Error State
        this.fail;
    }

    moar_listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        // moar_listy_entries -> ListSep listy_entries
        desires = [Toke_ListSep];
        if (toker.sees(desires) != nil) {
            "moar_listy_entries -> ListSep listy_entries
".post;
            noad.add_toke("Toke_ListSep", toker.burn(Toke_ListSep));
            this.listy_entries(noad);
            ^noad;
        };

        // <e>
        ^noad;
    }

    nouny {
        | parent |

        var noad = SkoarNoad.new("nouny", nil, parent);
        var desires = nil;

        // nouny -> cthulhu
        desires = [Toke_LWing];
        if (toker.sees(desires) != nil) {
            "nouny -> cthulhu
".post;
            noad.add_noad(this.cthulhu(noad));
            ^noad;
        };

        // nouny -> noaty
        desires = [Toke_CurNoat, Toke_Choard, Toke_VectorNoat, Toke_Symbol, Toke_ListS];
        if (toker.sees(desires) != nil) {
            "nouny -> noaty
".post;
            noad.add_noad(this.noaty(noad));
            ^noad;
        };

        // nouny -> conditional
        desires = [Toke_CondS];
        if (toker.sees(desires) != nil) {
            "nouny -> conditional
".post;
            noad.add_noad(this.conditional(noad));
            ^noad;
        };

        // nouny -> nouny_literal
        desires = [Toke_Tuplet, Toke_String, Toke_Float, Toke_Caesura, Toke_Slur,
                   Toke_Int];
        if (toker.sees(desires) != nil) {
            "nouny -> nouny_literal
".post;
            this.nouny_literal(noad);
            ^noad;
        };

        // nouny -> accidentally
        desires = [Toke_AccSharp, Toke_AccNatural, Toke_AccFlat];
        if (toker.sees(desires) != nil) {
            "nouny -> accidentally
".post;
            noad.add_noad(this.accidentally(noad));
            ^noad;
        };

        // nouny -> musical_keyword
        desires = [Toke_QuindicesimaB, Toke_DynForte, Toke_DynSFZ, Toke_DubRep, Toke_Portamento,
                   Toke_PedalDown, Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_QuindicesimaA,
                   Toke_OttavaA, Toke_Loco, Toke_Rep, Toke_DynPiano];
        if (toker.sees(desires) != nil) {
            "nouny -> musical_keyword
".post;
            noad.add_noad(this.musical_keyword(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter {
        | parent |

        var noad = SkoarNoad.new("meter", nil, parent);
        var desires = nil;

        // meter -> MeterS meter_stmts MeterE
        desires = [Toke_MeterS];
        if (toker.sees(desires) != nil) {
            "meter -> MeterS meter_stmts MeterE
".post;
            noad.add_toke("Toke_MeterS", toker.burn(Toke_MeterS));
            this.meter_stmts(noad);
            noad.add_toke("Toke_MeterE", toker.burn(Toke_MeterE));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_symbolic {
        | parent |

        var noad = SkoarNoad.new("meter_symbolic", nil, parent);
        var desires = nil;

        // meter_symbolic -> optional_carrots Symbol msg_chain_node
        desires = [Toke_Carrots, Toke_Symbol];
        if (toker.sees(desires) != nil) {
            "meter_symbolic -> optional_carrots Symbol msg_chain_node
".post;
            noad.add_noad(this.optional_carrots(noad));
            noad.add_toke("Toke_Symbol", toker.burn(Toke_Symbol));
            noad.add_noad(this.msg_chain_node(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    conditional {
        | parent |

        var noad = SkoarNoad.new("conditional", nil, parent);
        var desires = nil;

        // conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE
        desires = [Toke_CondS];
        if (toker.sees(desires) != nil) {
            "conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE
".post;
            noad.add_toke("Toke_CondS", toker.burn(Toke_CondS));
            noad.add_noad(this.optional_stmt(noad));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            noad.add_noad(this.boolean(noad));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            noad.add_noad(this.optional_stmt(noad));
            noad.add_toke("Toke_CondE", toker.burn(Toke_CondE));
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoaroid {
        | parent |

        var noad = SkoarNoad.new("skoaroid", nil, parent);
        var desires = nil;

        // skoaroid -> nouny skoaroid_prime
        desires = [Toke_AccFlat, Toke_Int, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_String, Toke_Caesura, Toke_Loco, Toke_Rep, Toke_Slur];
        if (toker.sees(desires) != nil) {
            "skoaroid -> nouny skoaroid_prime
".post;
            noad.add_noad(this.nouny(noad));
            this.skoaroid_prime(noad);
            ^noad;
        };

        // Error State
        this.fail;
    }

    msg {
        | parent |

        var noad = SkoarNoad.new("msg", nil, parent);
        var desires = nil;

        // msg -> MsgNameWithArgs listy_suffix
        desires = [Toke_MsgNameWithArgs];
        if (toker.sees(desires) != nil) {
            "msg -> MsgNameWithArgs listy_suffix
".post;
            noad.add_toke("Toke_MsgNameWithArgs", toker.burn(Toke_MsgNameWithArgs));
            this.listy_suffix(noad);
            ^noad;
        };

        // msg -> MsgName
        desires = [Toke_MsgName];
        if (toker.sees(desires) != nil) {
            "msg -> MsgName
".post;
            noad.add_toke("Toke_MsgName", toker.burn(Toke_MsgName));
            ^noad;
        };

        // msg -> listy
        desires = [Toke_ListS];
        if (toker.sees(desires) != nil) {
            "msg -> listy
".post;
            noad.add_noad(this.listy(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    accidentally {
        | parent |

        var noad = SkoarNoad.new("accidentally", nil, parent);
        var desires = nil;

        // accidentally -> acc noaty
        desires = [Toke_AccSharp, Toke_AccNatural, Toke_AccFlat];
        if (toker.sees(desires) != nil) {
            "accidentally -> acc noaty
".post;
            noad.add_noad(this.acc(noad));
            noad.add_noad(this.noaty(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    stmt {
        | parent |

        var noad = SkoarNoad.new("stmt", nil, parent);
        var desires = nil;

        // stmt -> optional_carrots skoaroid msg_chain_node
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_Carrots, Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat,
                   Toke_Int];
        if (toker.sees(desires) != nil) {
            "stmt -> optional_carrots skoaroid msg_chain_node
".post;
            noad.add_noad(this.optional_carrots(noad));
            noad.add_noad(this.skoaroid(noad));
            noad.add_noad(this.msg_chain_node(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy_suffix {
        | parent |

        var noad = parent;
        var desires = nil;

        // listy_suffix -> listy_entries ListE
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat, Toke_Int];
        if (toker.sees(desires) != nil) {
            "listy_suffix -> listy_entries ListE
".post;
            this.listy_entries(noad);
            noad.add_toke("Toke_ListE", toker.burn(Toke_ListE));
            ^noad;
        };

        // Error State
        this.fail;
    }

    phrasey {
        | parent |

        var noad = parent;
        var desires = nil;

        // phrasey -> Comment
        desires = [Toke_Comment];
        if (toker.sees(desires) != nil) {
            "phrasey -> Comment
".post;
            noad.add_toke("Toke_Comment", toker.burn(Toke_Comment));
            ^noad;
        };

        // phrasey -> marker
        desires = [Toke_Volta, Toke_Segno, Toke_Bars, Toke_Fine, Toke_Coda];
        if (toker.sees(desires) != nil) {
            "phrasey -> marker
".post;
            noad.add_noad(this.marker(noad));
            ^noad;
        };

        // phrasey -> meter
        desires = [Toke_MeterS];
        if (toker.sees(desires) != nil) {
            "phrasey -> meter
".post;
            noad.add_noad(this.meter(noad));
            ^noad;
        };

        // phrasey -> skoaroid
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat, Toke_Int];
        if (toker.sees(desires) != nil) {
            "phrasey -> skoaroid
".post;
            noad.add_noad(this.skoaroid(noad));
            ^noad;
        };

        // phrasey -> dal_goto
        desires = [Toke_DaCapo, Toke_DalSegno];
        if (toker.sees(desires) != nil) {
            "phrasey -> dal_goto
".post;
            noad.add_noad(this.dal_goto(noad));
            ^noad;
        };

        // phrasey -> beat
        desires = [Toke_Quarters, Toke_Eighths, Toke_Quavers, Toke_Crotchets, Toke_Slash];
        if (toker.sees(desires) != nil) {
            "phrasey -> beat
".post;
            noad.add_noad(this.beat(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoaroid_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        // skoaroid_prime -> assignment skoaroid_prime
        desires = [Toke_AssOp];
        if (toker.sees(desires) != nil) {
            "skoaroid_prime -> assignment skoaroid_prime
".post;
            noad.add_noad(this.assignment(noad));
            this.skoaroid_prime(noad);
            ^noad;
        };

        // <e>
        ^noad;
    }

    noat_reference {
        | parent |

        var noad = SkoarNoad.new("noat_reference", nil, parent);
        var desires = nil;

        // noat_reference -> Symbol
        desires = [Toke_Symbol];
        if (toker.sees(desires) != nil) {
            "noat_reference -> Symbol
".post;
            noad.add_toke("Toke_Symbol", toker.burn(Toke_Symbol));
            ^noad;
        };

        // noat_reference -> CurNoat
        desires = [Toke_CurNoat];
        if (toker.sees(desires) != nil) {
            "noat_reference -> CurNoat
".post;
            noad.add_toke("Toke_CurNoat", toker.burn(Toke_CurNoat));
            ^noad;
        };

        // noat_reference -> listy
        desires = [Toke_ListS];
        if (toker.sees(desires) != nil) {
            "noat_reference -> listy
".post;
            noad.add_noad(this.listy(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    clef {
        | parent |

        var noad = SkoarNoad.new("clef", nil, parent);
        var desires = nil;

        // clef -> TrebleClef
        desires = [Toke_TrebleClef];
        if (toker.sees(desires) != nil) {
            "clef -> TrebleClef
".post;
            noad.add_toke("Toke_TrebleClef", toker.burn(Toke_TrebleClef));
            ^noad;
        };

        // clef -> BassClef
        desires = [Toke_BassClef];
        if (toker.sees(desires) != nil) {
            "clef -> BassClef
".post;
            noad.add_toke("Toke_BassClef", toker.burn(Toke_BassClef));
            ^noad;
        };

        // clef -> AltoClef
        desires = [Toke_AltoClef];
        if (toker.sees(desires) != nil) {
            "clef -> AltoClef
".post;
            noad.add_toke("Toke_AltoClef", toker.burn(Toke_AltoClef));
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy {
        | parent |

        var noad = SkoarNoad.new("listy", nil, parent);
        var desires = nil;

        // listy -> ListS listy_suffix
        desires = [Toke_ListS];
        if (toker.sees(desires) != nil) {
            "listy -> ListS listy_suffix
".post;
            noad.add_toke("Toke_ListS", toker.burn(Toke_ListS));
            this.listy_suffix(noad);
            ^noad;
        };

        // Error State
        this.fail;
    }

    cthulhu_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        // cthulhu_prime -> boolean CondSep RWing
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat, Toke_Int];
        if (toker.sees(desires) != nil) {
            "cthulhu_prime -> boolean CondSep RWing
".post;
            noad.add_noad(this.boolean(noad));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            noad.add_toke("Toke_RWing", toker.burn(Toke_RWing));
            ^noad;
        };

        // cthulhu_prime -> Nosey CondSep RWing
        desires = [Toke_Nosey];
        if (toker.sees(desires) != nil) {
            "cthulhu_prime -> Nosey CondSep RWing
".post;
            noad.add_toke("Toke_Nosey", toker.burn(Toke_Nosey));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            noad.add_toke("Toke_RWing", toker.burn(Toke_RWing));
            ^noad;
        };

        // Error State
        this.fail;
    }

    beat {
        | parent |

        var noad = SkoarNoad.new("beat", nil, parent);
        var desires = nil;

        // beat -> Crotchets
        desires = [Toke_Crotchets];
        if (toker.sees(desires) != nil) {
            "beat -> Crotchets
".post;
            noad.add_toke("Toke_Crotchets", toker.burn(Toke_Crotchets));
            ^noad;
        };

        // beat -> Quavers
        desires = [Toke_Quavers];
        if (toker.sees(desires) != nil) {
            "beat -> Quavers
".post;
            noad.add_toke("Toke_Quavers", toker.burn(Toke_Quavers));
            ^noad;
        };

        // beat -> Quarters
        desires = [Toke_Quarters];
        if (toker.sees(desires) != nil) {
            "beat -> Quarters
".post;
            noad.add_toke("Toke_Quarters", toker.burn(Toke_Quarters));
            ^noad;
        };

        // beat -> Eighths
        desires = [Toke_Eighths];
        if (toker.sees(desires) != nil) {
            "beat -> Eighths
".post;
            noad.add_toke("Toke_Eighths", toker.burn(Toke_Eighths));
            ^noad;
        };

        // beat -> Slash
        desires = [Toke_Slash];
        if (toker.sees(desires) != nil) {
            "beat -> Slash
".post;
            noad.add_toke("Toke_Slash", toker.burn(Toke_Slash));
            ^noad;
        };

        // Error State
        this.fail;
    }

    acc {
        | parent |

        var noad = SkoarNoad.new("acc", nil, parent);
        var desires = nil;

        // acc -> AccSharp
        desires = [Toke_AccSharp];
        if (toker.sees(desires) != nil) {
            "acc -> AccSharp
".post;
            noad.add_toke("Toke_AccSharp", toker.burn(Toke_AccSharp));
            ^noad;
        };

        // acc -> AccNatural
        desires = [Toke_AccNatural];
        if (toker.sees(desires) != nil) {
            "acc -> AccNatural
".post;
            noad.add_toke("Toke_AccNatural", toker.burn(Toke_AccNatural));
            ^noad;
        };

        // acc -> AccFlat
        desires = [Toke_AccFlat];
        if (toker.sees(desires) != nil) {
            "acc -> AccFlat
".post;
            noad.add_toke("Toke_AccFlat", toker.burn(Toke_AccFlat));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_stmts {
        | parent |

        var noad = parent;
        var desires = nil;

        // meter_stmts -> meter_stmt meter_stmts
        desires = [Toke_Symbol, Toke_Carrots, Toke_AltoClef, Toke_TrebleClef, Toke_BassClef,
                   Toke_Int];
        if (toker.sees(desires) != nil) {
            "meter_stmts -> meter_stmt meter_stmts
".post;
            noad.add_noad(this.meter_stmt(noad));
            this.meter_stmts(noad);
            ^noad;
        };

        // <e>
        ^noad;
    }

    skoar {
        | parent |

        var noad = SkoarNoad.new("skoar", nil, parent);
        var desires = nil;

        // skoar -> phrases
        desires = [Toke_CondS, Toke_Float, Toke_DaCapo, Toke_PedalDown, Toke_OttavaB,
                   Toke_Tuplet, Toke_CurNoat, Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_Quavers,
                   Toke_AccNatural, Toke_AccSharp, Toke_MeterS, Toke_LWing, Toke_Coda,
                   Toke_Choard, Toke_String, Toke_Crotchets, Toke_Slash, Toke_Segno,
                   Toke_Rep, Toke_Int, Toke_Slur, Toke_AccFlat, Toke_EOF,
                   Toke_DynForte, Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Fine,
                   Toke_DynFP, Toke_PedalUp, Toke_OttavaA, Toke_VectorNoat, Toke_Symbol,
                   Toke_Bars, Toke_Portamento, Toke_DalSegno, Toke_Comment, Toke_Eighths,
                   Toke_Volta, Toke_Quarters, Toke_Caesura, Toke_Loco, Toke_DynPiano];
        if (toker.sees(desires) != nil) {
            "skoar -> phrases
".post;
            this.phrases(noad);
            ^noad;
        };

        // Error State
        this.fail;
    }

    boolean {
        | parent |

        var noad = SkoarNoad.new("boolean", nil, parent);
        var desires = nil;

        // boolean -> skoaroid BooleanOp skoaroid
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat, Toke_Int];
        if (toker.sees(desires) != nil) {
            "boolean -> skoaroid BooleanOp skoaroid
".post;
            noad.add_noad(this.skoaroid(noad));
            noad.add_toke("Toke_BooleanOp", toker.burn(Toke_BooleanOp));
            noad.add_noad(this.skoaroid(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_stmt {
        | parent |

        var noad = SkoarNoad.new("optional_stmt", nil, parent);
        var desires = nil;

        // optional_stmt -> stmt
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_Carrots, Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat,
                   Toke_Int];
        if (toker.sees(desires) != nil) {
            "optional_stmt -> stmt
".post;
            noad.add_noad(this.stmt(noad));
            ^noad;
        };

        // <e>
        ^noad;
    }

    al_whatnow {
        | parent |

        var noad = SkoarNoad.new("al_whatnow", nil, parent);
        var desires = nil;

        // al_whatnow -> AlCoda
        desires = [Toke_AlCoda];
        if (toker.sees(desires) != nil) {
            "al_whatnow -> AlCoda
".post;
            noad.add_toke("Toke_AlCoda", toker.burn(Toke_AlCoda));
            ^noad;
        };

        // al_whatnow -> AlSegno
        desires = [Toke_AlSegno];
        if (toker.sees(desires) != nil) {
            "al_whatnow -> AlSegno
".post;
            noad.add_toke("Toke_AlSegno", toker.burn(Toke_AlSegno));
            ^noad;
        };

        // al_whatnow -> AlFine
        desires = [Toke_AlFine];
        if (toker.sees(desires) != nil) {
            "al_whatnow -> AlFine
".post;
            noad.add_toke("Toke_AlFine", toker.burn(Toke_AlFine));
            ^noad;
        };

        // <e>
        ^noad;
    }

    meteroid {
        | parent |

        var noad = SkoarNoad.new("meteroid", nil, parent);
        var desires = nil;

        // meteroid -> meter_symbolic
        desires = [Toke_Symbol, Toke_Carrots];
        if (toker.sees(desires) != nil) {
            "meteroid -> meter_symbolic
".post;
            noad.add_noad(this.meter_symbolic(noad));
            ^noad;
        };

        // meteroid -> clef
        desires = [Toke_AltoClef, Toke_TrebleClef, Toke_BassClef];
        if (toker.sees(desires) != nil) {
            "meteroid -> clef
".post;
            noad.add_noad(this.clef(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    musical_keyword {
        | parent |

        var noad = SkoarNoad.new("musical_keyword", nil, parent);
        var desires = nil;

        // musical_keyword -> dynamic
        desires = [Toke_DynFP, Toke_DynForte, Toke_DynSFZ, Toke_DynPiano];
        if (toker.sees(desires) != nil) {
            "musical_keyword -> dynamic
".post;
            noad.add_noad(this.dynamic(noad));
            ^noad;
        };

        // musical_keyword -> ottavas
        desires = [Toke_OttavaB, Toke_QuindicesimaB, Toke_QuindicesimaA, Toke_OttavaA, Toke_Loco];
        if (toker.sees(desires) != nil) {
            "musical_keyword -> ottavas
".post;
            noad.add_noad(this.ottavas(noad));
            ^noad;
        };

        // musical_keyword -> pedally
        desires = [Toke_PedalUp, Toke_PedalDown];
        if (toker.sees(desires) != nil) {
            "musical_keyword -> pedally
".post;
            noad.add_noad(this.pedally(noad));
            ^noad;
        };

        // musical_keyword -> musical_keyword_misc
        desires = [Toke_Portamento, Toke_Rep, Toke_DubRep];
        if (toker.sees(desires) != nil) {
            "musical_keyword -> musical_keyword_misc
".post;
            noad.add_noad(this.musical_keyword_misc(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    marker {
        | parent |

        var noad = SkoarNoad.new("marker", nil, parent);
        var desires = nil;

        // marker -> Segno
        desires = [Toke_Segno];
        if (toker.sees(desires) != nil) {
            "marker -> Segno
".post;
            noad.add_toke("Toke_Segno", toker.burn(Toke_Segno));
            ^noad;
        };

        // marker -> Fine
        desires = [Toke_Fine];
        if (toker.sees(desires) != nil) {
            "marker -> Fine
".post;
            noad.add_toke("Toke_Fine", toker.burn(Toke_Fine));
            ^noad;
        };

        // marker -> coda
        desires = [Toke_Coda];
        if (toker.sees(desires) != nil) {
            "marker -> coda
".post;
            noad.add_noad(this.coda(noad));
            ^noad;
        };

        // marker -> Volta
        desires = [Toke_Volta];
        if (toker.sees(desires) != nil) {
            "marker -> Volta
".post;
            noad.add_toke("Toke_Volta", toker.burn(Toke_Volta));
            ^noad;
        };

        // marker -> Bars
        desires = [Toke_Bars];
        if (toker.sees(desires) != nil) {
            "marker -> Bars
".post;
            noad.add_toke("Toke_Bars", toker.burn(Toke_Bars));
            ^noad;
        };

        // Error State
        this.fail;
    }

    dynamic {
        | parent |

        var noad = SkoarNoad.new("dynamic", nil, parent);
        var desires = nil;

        // dynamic -> DynPiano
        desires = [Toke_DynPiano];
        if (toker.sees(desires) != nil) {
            "dynamic -> DynPiano
".post;
            noad.add_toke("Toke_DynPiano", toker.burn(Toke_DynPiano));
            ^noad;
        };

        // dynamic -> DynForte
        desires = [Toke_DynForte];
        if (toker.sees(desires) != nil) {
            "dynamic -> DynForte
".post;
            noad.add_toke("Toke_DynForte", toker.burn(Toke_DynForte));
            ^noad;
        };

        // dynamic -> DynSFZ
        desires = [Toke_DynSFZ];
        if (toker.sees(desires) != nil) {
            "dynamic -> DynSFZ
".post;
            noad.add_toke("Toke_DynSFZ", toker.burn(Toke_DynSFZ));
            ^noad;
        };

        // dynamic -> DynFP
        desires = [Toke_DynFP];
        if (toker.sees(desires) != nil) {
            "dynamic -> DynFP
".post;
            noad.add_toke("Toke_DynFP", toker.burn(Toke_DynFP));
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_carrots {
        | parent |

        var noad = SkoarNoad.new("optional_carrots", nil, parent);
        var desires = nil;

        // optional_carrots -> Carrots
        desires = [Toke_Carrots];
        if (toker.sees(desires) != nil) {
            "optional_carrots -> Carrots
".post;
            noad.add_toke("Toke_Carrots", toker.burn(Toke_Carrots));
            ^noad;
        };

        // <e>
        ^noad;
    }

    meter_ass_r {
        | parent |

        var noad = parent;
        var desires = nil;

        // meter_ass_r -> Symbol
        desires = [Toke_Symbol];
        if (toker.sees(desires) != nil) {
            "meter_ass_r -> Symbol
".post;
            noad.add_toke("Toke_Symbol", toker.burn(Toke_Symbol));
            ^noad;
        };

        // meter_ass_r -> meter_beat
        desires = [Toke_Quarters, Toke_Eighths, Toke_Quavers, Toke_Crotchets, Toke_Slash];
        if (toker.sees(desires) != nil) {
            "meter_ass_r -> meter_beat
".post;
            noad.add_noad(this.meter_beat(noad));
            ^noad;
        };

        // meter_ass_r -> dynamic
        desires = [Toke_DynFP, Toke_DynForte, Toke_DynSFZ, Toke_DynPiano];
        if (toker.sees(desires) != nil) {
            "meter_ass_r -> dynamic
".post;
            noad.add_noad(this.dynamic(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_stmt {
        | parent |

        var noad = SkoarNoad.new("meter_stmt", nil, parent);
        var desires = nil;

        // meter_stmt -> Int meter_stmt_numbery
        desires = [Toke_Int];
        if (toker.sees(desires) != nil) {
            "meter_stmt -> Int meter_stmt_numbery
".post;
            noad.add_toke("Toke_Int", toker.burn(Toke_Int));
            this.meter_stmt_numbery(noad);
            ^noad;
        };

        // meter_stmt -> meteroid
        desires = [Toke_Symbol, Toke_Carrots, Toke_AltoClef, Toke_TrebleClef, Toke_BassClef];
        if (toker.sees(desires) != nil) {
            "meter_stmt -> meteroid
".post;
            noad.add_noad(this.meteroid(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_stmt_numbery {
        | parent |

        var noad = parent;
        var desires = nil;

        // meter_stmt_numbery -> meter_ass
        desires = [Toke_AssOp];
        if (toker.sees(desires) != nil) {
            "meter_stmt_numbery -> meter_ass
".post;
            noad.add_noad(this.meter_ass(noad));
            ^noad;
        };

        // meter_stmt_numbery -> meter_sig_prime
        desires = [Toke_Slash];
        if (toker.sees(desires) != nil) {
            "meter_stmt_numbery -> meter_sig_prime
".post;
            noad.add_noad(this.meter_sig_prime(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_beat {
        | parent |

        var noad = SkoarNoad.new("meter_beat", nil, parent);
        var desires = nil;

        // meter_beat -> Crotchets
        desires = [Toke_Crotchets];
        if (toker.sees(desires) != nil) {
            "meter_beat -> Crotchets
".post;
            noad.add_toke("Toke_Crotchets", toker.burn(Toke_Crotchets));
            ^noad;
        };

        // meter_beat -> Quavers
        desires = [Toke_Quavers];
        if (toker.sees(desires) != nil) {
            "meter_beat -> Quavers
".post;
            noad.add_toke("Toke_Quavers", toker.burn(Toke_Quavers));
            ^noad;
        };

        // meter_beat -> Quarters
        desires = [Toke_Quarters];
        if (toker.sees(desires) != nil) {
            "meter_beat -> Quarters
".post;
            noad.add_toke("Toke_Quarters", toker.burn(Toke_Quarters));
            ^noad;
        };

        // meter_beat -> Eighths
        desires = [Toke_Eighths];
        if (toker.sees(desires) != nil) {
            "meter_beat -> Eighths
".post;
            noad.add_toke("Toke_Eighths", toker.burn(Toke_Eighths));
            ^noad;
        };

        // meter_beat -> Slash
        desires = [Toke_Slash];
        if (toker.sees(desires) != nil) {
            "meter_beat -> Slash
".post;
            noad.add_toke("Toke_Slash", toker.burn(Toke_Slash));
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_al_coda {
        | parent |

        var noad = SkoarNoad.new("optional_al_coda", nil, parent);
        var desires = nil;

        // optional_al_coda -> AlCoda
        desires = [Toke_AlCoda];
        if (toker.sees(desires) != nil) {
            "optional_al_coda -> AlCoda
".post;
            noad.add_toke("Toke_AlCoda", toker.burn(Toke_AlCoda));
            ^noad;
        };

        // <e>
        ^noad;
    }

    listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        // listy_entries -> skoaroid moar_listy_entries
        desires = [Toke_Rep, Toke_Slur, Toke_DynPiano, Toke_CondS, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Float, Toke_PedalDown,
                   Toke_OttavaB, Toke_DynFP, Toke_PedalUp, Toke_Tuplet, Toke_CurNoat,
                   Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_VectorNoat, Toke_Symbol,
                   Toke_AccSharp, Toke_AccNatural, Toke_LWing, Toke_Portamento, Toke_Choard,
                   Toke_String, Toke_Caesura, Toke_Loco, Toke_AccFlat, Toke_Int];
        if (toker.sees(desires) != nil) {
            "listy_entries -> skoaroid moar_listy_entries
".post;
            noad.add_noad(this.skoaroid(noad));
            this.moar_listy_entries(noad);
            ^noad;
        };

        // Error State
        this.fail;
    }

    pedally {
        | parent |

        var noad = SkoarNoad.new("pedally", nil, parent);
        var desires = nil;

        // pedally -> PedalDown
        desires = [Toke_PedalDown];
        if (toker.sees(desires) != nil) {
            "pedally -> PedalDown
".post;
            noad.add_toke("Toke_PedalDown", toker.burn(Toke_PedalDown));
            ^noad;
        };

        // pedally -> PedalUp
        desires = [Toke_PedalUp];
        if (toker.sees(desires) != nil) {
            "pedally -> PedalUp
".post;
            noad.add_toke("Toke_PedalUp", toker.burn(Toke_PedalUp));
            ^noad;
        };

        // Error State
        this.fail;
    }

    dal_goto {
        | parent |

        var noad = SkoarNoad.new("dal_goto", nil, parent);
        var desires = nil;

        // dal_goto -> DaCapo al_whatnow
        desires = [Toke_DaCapo];
        if (toker.sees(desires) != nil) {
            "dal_goto -> DaCapo al_whatnow
".post;
            noad.add_toke("Toke_DaCapo", toker.burn(Toke_DaCapo));
            noad.add_noad(this.al_whatnow(noad));
            ^noad;
        };

        // dal_goto -> DalSegno al_whatnow
        desires = [Toke_DalSegno];
        if (toker.sees(desires) != nil) {
            "dal_goto -> DalSegno al_whatnow
".post;
            noad.add_toke("Toke_DalSegno", toker.burn(Toke_DalSegno));
            noad.add_noad(this.al_whatnow(noad));
            ^noad;
        };

        // Error State
        this.fail;
    }

    cthulhu {
        | parent |

        var noad = SkoarNoad.new("cthulhu", nil, parent);
        var desires = nil;

        // cthulhu -> LWing CondSep cthulhu_prime
        desires = [Toke_LWing];
        if (toker.sees(desires) != nil) {
            "cthulhu -> LWing CondSep cthulhu_prime
".post;
            noad.add_toke("Toke_LWing", toker.burn(Toke_LWing));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            this.cthulhu_prime(noad);
            ^noad;
        };

        // Error State
        this.fail;
    }

    meter_sig_prime {
        | parent |

        var noad = SkoarNoad.new("meter_sig_prime", nil, parent);
        var desires = nil;

        // meter_sig_prime -> Slash Int
        desires = [Toke_Slash];
        if (toker.sees(desires) != nil) {
            "meter_sig_prime -> Slash Int
".post;
            noad.add_toke("Toke_Slash", toker.burn(Toke_Slash));
            noad.add_toke("Toke_Int", toker.burn(Toke_Int));
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_soak {
        | parent |

        var noad = SkoarNoad.new("optional_soak", nil, parent);
        var desires = nil;

        // optional_soak -> Soak
        desires = [Toke_Soak];
        if (toker.sees(desires) != nil) {
            "optional_soak -> Soak
".post;
            noad.add_toke("Toke_Soak", toker.burn(Toke_Soak));
            ^noad;
        };

        // <e>
        ^noad;
    }

    phrases {
        | parent |

        var noad = parent;
        var desires = nil;

        // phrases -> phrasey phrases
        desires = [Toke_CondS, Toke_Float, Toke_DaCapo, Toke_PedalDown, Toke_OttavaB,
                   Toke_Tuplet, Toke_CurNoat, Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_Quavers,
                   Toke_AccSharp, Toke_AccNatural, Toke_MeterS, Toke_LWing, Toke_Coda,
                   Toke_Choard, Toke_String, Toke_Crotchets, Toke_Slash, Toke_Segno,
                   Toke_Slur, Toke_Int, Toke_Rep, Toke_AccFlat, Toke_DynForte,
                   Toke_DynSFZ, Toke_DubRep, Toke_ListS, Toke_Fine, Toke_DynFP,
                   Toke_PedalUp, Toke_OttavaA, Toke_VectorNoat, Toke_Symbol, Toke_Bars,
                   Toke_Portamento, Toke_DalSegno, Toke_Comment, Toke_Volta, Toke_Quarters,
                   Toke_Eighths, Toke_Caesura, Toke_Loco, Toke_DynPiano];
        if (toker.sees(desires) != nil) {
            "phrases -> phrasey phrases
".post;
            this.phrasey(noad);
            this.phrases(noad);
            ^noad;
        };

        // <e>
        ^noad;
    }

}

