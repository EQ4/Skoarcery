// =======================================================================================
// lex.sc - Generated by Code_Sc_Lexer on 2014-04-26 02:33:38.160637 for SuperCollider 3.6
// =======================================================================================

// --------------
// Abstract Token
// --------------
SkoarToke {

    var <buf;
    classvar <regex = nil;

    *new {
        | s |
        ^super.new.init( s )
    }

    init {
        | s |
        buf = s;
    }

    // how many characters to burn from the buffer
    burn {^buf.size}

    // override and return nil for no match, new toke otherwise
    *match {}

    *match_toke {
        | buf, offs, toke_class |

        var o = buf.findRegexp(toke_class.regex, offs);

        if (o.size > 0) {
            ^SkoarTokeclass.new(o[0][1]);
        }

        ^nil
    }

}


// ---------------------
// Whitespace is special
// ---------------------
Toke_WS : SkoarToke {
classvar <regex = "^\s*";

    *burn {
        | buf, offs |

        var o = buf.findRegexp("^\s*", offs);

        if (o.size > 0) {
            ^o[0][1].size;
        }

        ^0
    }
}


// --------------
// Everyday Tokes
// --------------
Toke_Portamento : SkoarToke {
    classvar <regex = "~~~";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Portamento) }
}


Toke_Slur : SkoarToke {
    classvar <regex = "++";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Slur) }
}


Toke_MsgName : SkoarToke {
    classvar <regex = "[a-zA-Z_][a-zA-Z0-9_]*";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_MsgName) }
}


Toke_CondS : SkoarToke {
    classvar <regex = "{";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_CondS) }
}


Toke_Coda : SkoarToke {
    classvar <regex = "\(\+\)";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Coda) }
}


Toke_AlSegno : SkoarToke {
    classvar <regex = "al segno";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AlSegno) }
}


Toke_DynForte : SkoarToke {
    classvar <regex = "mf|f+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DynForte) }
}


Toke_ListE : SkoarToke {
    classvar <regex = ">";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_ListE) }
}


Toke_ListSep : SkoarToke {
    classvar <regex = ",";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_ListSep) }
}


Toke_Int : SkoarToke {
    classvar <regex = "(+|-)?(0|[1-9)[0-9]+)";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Int) }
}


Toke_DynSFZ : SkoarToke {
    classvar <regex = "sfz";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DynSFZ) }
}


Toke_AssOp : SkoarToke {
    classvar <regex = "=>";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AssOp) }
}


Toke_TrebleClef : SkoarToke {
    classvar <regex = "G:|treble:";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_TrebleClef) }
}


Toke_QuindicesimaB : SkoarToke {
    classvar <regex = "15mb|alla quindicesimb";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_QuindicesimaB) }
}


Toke_Volta : SkoarToke {
    classvar <regex = "\[\d+\.]";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Volta) }
}


Toke_DalSegno : SkoarToke {
    classvar <regex = "D\.S\.|Dal Segno";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DalSegno) }
}


Toke_LWing : SkoarToke {
    classvar <regex = "\^\^\(";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_LWing) }
}


Toke_VectorNoat : SkoarToke {
    classvar <regex = "[a-g]#*|b*";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_VectorNoat) }
}


Toke_ZedPlus : SkoarToke {
    classvar <regex = "[1-9][0-9]+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_ZedPlus) }
}


Toke_QuindicesimaA : SkoarToke {
    classvar <regex = "15ma|alla quindicesima";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_QuindicesimaA) }
}


Toke_Tuplet : SkoarToke {
    classvar <regex = "/\d+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Tuplet) }
}


Toke_Quavers : SkoarToke {
    classvar <regex = "o+/";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Quavers) }
}


Toke_OttavaB : SkoarToke {
    classvar <regex = "8v?b|ottava (bassa|sotto)";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_OttavaB) }
}


Toke_PedalDown : SkoarToke {
    classvar <regex = "Ped\.";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_PedalDown) }
}


Toke_Fine : SkoarToke {
    classvar <regex = "fine";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Fine) }
}


Toke_Slash : SkoarToke {
    classvar <regex = "/";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Slash) }
}


Toke_MsgNameWithArgs : SkoarToke {
    classvar <regex = "[a-zA-Z_][a-zA-Z0-9_]*<";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_MsgNameWithArgs) }
}


Toke_Float : SkoarToke {
    classvar <regex = "(+|-)?(0|[1-9)[0-9]+)\.[0-9]+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Float) }
}


Toke_OttavaA : SkoarToke {
    classvar <regex = "8v?a|ottava (alta|sopra)|all' ottava";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_OttavaA) }
}


Toke_PedalUp : SkoarToke {
    classvar <regex = "*";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_PedalUp) }
}


Toke_DynFP : SkoarToke {
    classvar <regex = "fp";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DynFP) }
}


Toke_Symbol : SkoarToke {
    classvar <regex = "\[a-zA-Z][a-zA-Z0-9]+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Symbol) }
}


Toke_Nosey : SkoarToke {
    classvar <regex = ",";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Nosey) }
}


Toke_Colon : SkoarToke {
    classvar <regex = ":";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Colon) }
}


Toke_Goto : SkoarToke {
    classvar <regex = ":";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Goto) }
}


Toke_AccSharp : SkoarToke {
    classvar <regex = "#|sharp";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AccSharp) }
}


Toke_Quarters : SkoarToke {
    classvar <regex = "\]+\.+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Quarters) }
}


Toke_MeterE : SkoarToke {
    classvar <regex = "!>";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_MeterE) }
}


Toke_DynPiano : SkoarToke {
    classvar <regex = "mp|p+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DynPiano) }
}


Toke_AlFine : SkoarToke {
    classvar <regex = "al fine";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AlFine) }
}


Toke_AccNatural : SkoarToke {
    classvar <regex = "nat";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AccNatural) }
}


Toke_Eighths : SkoarToke {
    classvar <regex = "\]+\.+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Eighths) }
}


Toke_Rep : SkoarToke {
    classvar <regex = "\./\.";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Rep) }
}


Toke_Choard : SkoarToke {
    classvar <regex = "[A-G]([Mm0-9]|sus|dim)*";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Choard) }
}


Toke_MsgOp : SkoarToke {
    classvar <regex = "\.";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_MsgOp) }
}


Toke_CurNoat : SkoarToke {
    classvar <regex = "\$";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_CurNoat) }
}


Toke_Alto : SkoarToke {
    classvar <regex = "C:|alto:";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Alto) }
}


Toke_ListS : SkoarToke {
    classvar <regex = "<";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_ListS) }
}


Toke_NoatFlats : SkoarToke {
    classvar <regex = "b";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_NoatFlats) }
}


Toke_MeterS : SkoarToke {
    classvar <regex = "<!";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_MeterS) }
}


Toke_NoatSharps : SkoarToke {
    classvar <regex = "#";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_NoatSharps) }
}


Toke_String : SkoarToke {
    classvar <regex = "'[^']*[^\]'";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_String) }
}


Toke_AlCoda : SkoarToke {
    classvar <regex = "al(la)? coda";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AlCoda) }
}


Toke_Label : SkoarToke {
    classvar <regex = "[a-zA-Z][a-zA-Z0-9_]";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Label) }
}


Toke_DaCapo : SkoarToke {
    classvar <regex = "D\.C\.|Da Capo";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DaCapo) }
}


Toke_BassClef : SkoarToke {
    classvar <regex = "F:|bass:";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_BassClef) }
}


Toke_CondSep : SkoarToke {
    classvar <regex = ";";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_CondSep) }
}


Toke_Segno : SkoarToke {
    classvar <regex = "%S%|al segno";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Segno) }
}


Toke_Plus : SkoarToke {
    classvar <regex = "\+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Plus) }
}


Toke_AccFlat : SkoarToke {
    classvar <regex = "flat";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_AccFlat) }
}


Toke_MeterSig : SkoarToke {
    classvar <regex = "(\d+(\+\d)+/\d)";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_MeterSig) }
}


Toke_Carrots : SkoarToke {
    classvar <regex = "\^+(^\^\^\()";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Carrots) }
}


Toke_Loco : SkoarToke {
    classvar <regex = "loco";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Loco) }
}


Toke_CondE : SkoarToke {
    classvar <regex = "}";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_CondE) }
}


Toke_CondGo : SkoarToke {
    classvar <regex = "::";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_CondGo) }
}


Toke_RWing : SkoarToke {
    classvar <regex = "\)\^\^";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_RWing) }
}


Toke_Crotchets : SkoarToke {
    classvar <regex = "}+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Crotchets) }
}


Toke_Bars : SkoarToke {
    classvar <regex = "[\|]+";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Bars) }
}


Toke_DubRep : SkoarToke {
    classvar <regex = "/\.\|\./";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_DubRep) }
}


Toke_Caesura : SkoarToke {
    classvar <regex = "//";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Caesura) }
}


Toke_BooleanOp : SkoarToke {
    classvar <regex = "== | != | <= | >= | in | nin | and | or | xor";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_BooleanOp) }
}


Toke_Minus : SkoarToke {
    classvar <regex = "-";
    *match {
        | buf, offs | ^SkoarToke.match_token(buf, offs, Toke_Minus) }
}
