// ==================================================================================================================================
// rdpp.sc.sc - Generated by Code_Parser_Sc - Create Recursive Descent Predictive Parser on 2014-10-26 19:53:40 for SuperCollider 3.6
// ==================================================================================================================================

SkoarParseException : Exception {

}

SkoarParser {

    var <runtime, <toker, <deep, desirables;

    *new {
        | runtime |
        ^super.new.init( runtime )
    }

    init {
        | runtime |

        runtime = runtime;
        toker = runtime.toker;
        deep = 0;
        desirables = IdentityDictionary();
        this.init_desirables();
    }

    fail {
        toker.dump;
        SkoarParseException("Fail").throw;
    }

    fail_too_deep {
        "Parse tree too deep!".postln;
        toker.dump;
        SkoarParseException("Parse tree too deep").throw;
    }


    //print {
    //    | line, end |
    //    (line ++ end).postln;
    //}

    init_desirables {

        // seq_ref_prime
        desirables.put('seq_ref_prime -> MsgNameWithArgs listy_suffix', [Toke_MsgNameWithArgs]);
        desirables.put('seq_ref_prime -> MsgName', [Toke_MsgName]);

        // moar_args_entries
        desirables.put('moar_args_entries -> ListSep args_entries', [Toke_ListSep]);

        // args
        desirables.put('args -> ListS args_suffix', [Toke_ListS]);

        // skoarpion
        desirables.put('skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix', [Toke_SkoarpionStart]);

        // musical_keyword_misc
        desirables.put('musical_keyword_misc -> Rep', [Toke_Rep]);
        desirables.put('musical_keyword_misc -> Portamento', [Toke_Portamento]);
        desirables.put('musical_keyword_misc -> Carrot', [Toke_Carrot]);

        // stmt_prime
        desirables.put('stmt_prime -> assignment stmt_prime', [Toke_AssOp]);

        // al_x
        desirables.put('al_x -> AlCoda', [Toke_AlCoda]);
        desirables.put('al_x -> AlSegno', [Toke_AlSegno]);
        desirables.put('al_x -> AlFine', [Toke_AlFine]);

        // optional_voice
        desirables.put('optional_voice -> Voice', [Toke_Voice]);

        // listy
        desirables.put('listy -> ListS listy_suffix', [Toke_ListS]);

        // marker
        desirables.put('marker -> Segno', [Toke_Segno]);
        desirables.put('marker -> Fine', [Toke_Fine]);
        desirables.put('marker -> coda', [Toke_Coda]);
        desirables.put('marker -> Volta', [Toke_Volta]);
        desirables.put('marker -> Bars', [Toke_Bars]);

        // msg_chain_node
        desirables.put('msg_chain_node -> MsgOp msg msg_chain_node', [Toke_MsgOp]);

        // dynamic
        desirables.put('dynamic -> DynPiano', [Toke_DynPiano]);
        desirables.put('dynamic -> DynForte', [Toke_DynForte]);
        desirables.put('dynamic -> DynSFZ', [Toke_DynSFZ]);
        desirables.put('dynamic -> DynFP', [Toke_DynFP]);

        // optional_stmt
        desirables.put('optional_stmt -> stmt', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);
        desirables.put('optional_stmt -> Newline', [Toke_Newline]);

        // args_suffix
        desirables.put('args_suffix -> args_entries ListE', [Toke_SymbolName]);

        // stmt
        desirables.put('stmt -> skoaroid stmt_prime', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);

        // listy_suffix
        desirables.put('listy_suffix -> listy_entries ListE', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);
        desirables.put('listy_suffix -> ListE', [Toke_ListE]);

        // args_entries
        desirables.put('args_entries -> SymbolName moar_args_entries', [Toke_SymbolName]);

        // cthulhu
        desirables.put('cthulhu -> LWing CondSep cthulhu_prime', [Toke_LWing]);

        // conditional
        desirables.put('conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE', [Toke_CondS]);

        // beat
        desirables.put('beat -> Crotchets', [Toke_Crotchets]);
        desirables.put('beat -> Quavers', [Toke_Quavers]);
        desirables.put('beat -> Quarters', [Toke_Quarters]);
        desirables.put('beat -> Eighths', [Toke_Eighths]);
        desirables.put('beat -> Slash', [Toke_Slash]);

        // skrp_sig
        desirables.put('skrp_sig -> args', [Toke_ListS]);
        desirables.put('skrp_sig -> SymbolName optional_args', [Toke_SymbolName]);

        // optional_args
        desirables.put('optional_args -> args', [Toke_ListS]);

        // cthulhu_prime
        desirables.put('cthulhu_prime -> boolean CondSep RWing', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);
        desirables.put('cthulhu_prime -> Nosey CondSep RWing', [Toke_Nosey]);

        // musical_keyword
        desirables.put('musical_keyword -> dynamic', [Toke_DynSFZ, Toke_DynPiano, Toke_DynForte, Toke_DynFP]);
        desirables.put('musical_keyword -> ottavas', [Toke_OttavaB, Toke_QuindicesimaA, Toke_QuindicesimaB, Toke_Loco, Toke_OctaveShift,
                   Toke_OttavaA]);
        desirables.put('musical_keyword -> pedally', [Toke_PedalUp, Toke_PedalDown]);
        desirables.put('musical_keyword -> musical_keyword_misc', [Toke_Rep, Toke_Carrot, Toke_Portamento]);

        // skrp_sep_or_nl
        desirables.put('skrp_sep_or_nl -> Newline', [Toke_Newline]);
        desirables.put('skrp_sep_or_nl -> SkoarpionSep', [Toke_SkoarpionSep]);

        // branches
        desirables.put('branches -> branch branches', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_Quavers, Toke_Carrot,
                   Toke_CurNoat, Toke_Rep, Toke_DaCapo, Toke_DynSFZ, Toke_DynPiano,
                   Toke_Caesura, Toke_Loco, Toke_Coda, Toke_Bars, Toke_OttavaA,
                   Toke_Volta, Toke_Symbol, Toke_SeqRef, Toke_Crotchets, Toke_DalSegno,
                   Toke_Slur, Toke_DynForte, Toke_Quarters, Toke_Eighths, Toke_PedalDown,
                   Toke_Segno, Toke_LWing, Toke_Slash, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_Fine, Toke_Voice, Toke_CondS, Toke_Meter,
                   Toke_String, Toke_Choard, Toke_NamedNoat, Toke_Newline, Toke_ListS,
                   Toke_SkoarpionStart, Toke_Tuplet, Toke_Comment, Toke_Float, Toke_DynFP,
                   Toke_OctaveShift]);

        // optional_al_coda
        desirables.put('optional_al_coda -> AlCoda', [Toke_AlCoda]);

        // skrp_lines
        desirables.put('skrp_lines -> optional_voice phrases skrp_moar_lines', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_Quavers, Toke_Carrot,
                   Toke_CurNoat, Toke_Rep, Toke_DaCapo, Toke_DynSFZ, Toke_DynPiano,
                   Toke_Caesura, Toke_Loco, Toke_Coda, Toke_Bars, Toke_OttavaA,
                   Toke_Volta, Toke_Symbol, Toke_SeqRef, Toke_Crotchets, Toke_DalSegno,
                   Toke_Slur, Toke_DynForte, Toke_Quarters, Toke_Eighths, Toke_PedalDown,
                   Toke_Segno, Toke_LWing, Toke_Slash, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_Fine, Toke_Voice, Toke_SkoarpionSep, Toke_CondS,
                   Toke_Meter, Toke_String, Toke_Choard, Toke_SkoarpionEnd, Toke_NamedNoat,
                   Toke_Newline, Toke_ListS, Toke_SkoarpionStart, Toke_Tuplet, Toke_Comment,
                   Toke_Float, Toke_DynFP, Toke_OctaveShift]);

        // skoar
        desirables.put('skoar -> branches', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_Quavers, Toke_Carrot,
                   Toke_CurNoat, Toke_Rep, Toke_DaCapo, Toke_DynSFZ, Toke_DynPiano,
                   Toke_Caesura, Toke_Loco, Toke_Coda, Toke_Bars, Toke_OttavaA,
                   Toke_Volta, Toke_Symbol, Toke_SeqRef, Toke_Crotchets, Toke_DalSegno,
                   Toke_Slur, Toke_DynForte, Toke_Quarters, Toke_Eighths, Toke_PedalDown,
                   Toke_Segno, Toke_LWing, Toke_Slash, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_Fine, Toke_Voice, Toke_CondS, Toke_Meter,
                   Toke_String, Toke_Choard, Toke_EOF, Toke_NamedNoat, Toke_Newline,
                   Toke_ListS, Toke_SkoarpionStart, Toke_Tuplet, Toke_Comment, Toke_Float,
                   Toke_DynFP, Toke_OctaveShift]);

        // pedally
        desirables.put('pedally -> PedalDown', [Toke_PedalDown]);
        desirables.put('pedally -> PedalUp', [Toke_PedalUp]);

        // coda
        desirables.put('coda -> Coda optional_al_coda', [Toke_Coda]);

        // dal_goto
        desirables.put('dal_goto -> DaCapo al_x', [Toke_DaCapo]);
        desirables.put('dal_goto -> DalSegno al_x', [Toke_DalSegno]);

        // moar_listy_entries
        desirables.put('moar_listy_entries -> ListSep listy_entries', [Toke_ListSep]);
        desirables.put('moar_listy_entries -> Newline', [Toke_Newline]);

        // phrases
        desirables.put('phrases -> phrasey phrases', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_Quavers, Toke_CurNoat,
                   Toke_Rep, Toke_Carrot, Toke_DaCapo, Toke_DynSFZ, Toke_DynPiano,
                   Toke_Caesura, Toke_Loco, Toke_Coda, Toke_Bars, Toke_OttavaA,
                   Toke_Volta, Toke_Symbol, Toke_SeqRef, Toke_Crotchets, Toke_DalSegno,
                   Toke_Slur, Toke_DynForte, Toke_Quarters, Toke_Eighths, Toke_PedalDown,
                   Toke_Segno, Toke_LWing, Toke_Slash, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_Fine, Toke_CondS, Toke_Meter, Toke_String,
                   Toke_Choard, Toke_NamedNoat, Toke_ListS, Toke_SkoarpionStart, Toke_Tuplet,
                   Toke_Comment, Toke_Float, Toke_DynFP, Toke_OctaveShift]);

        // ottavas
        desirables.put('ottavas -> OctaveShift', [Toke_OctaveShift]);
        desirables.put('ottavas -> OttavaA', [Toke_OttavaA]);
        desirables.put('ottavas -> OttavaB', [Toke_OttavaB]);
        desirables.put('ottavas -> QuindicesimaA', [Toke_QuindicesimaA]);
        desirables.put('ottavas -> QuindicesimaB', [Toke_QuindicesimaB]);
        desirables.put('ottavas -> Loco', [Toke_Loco]);

        // msg
        desirables.put('msg -> MsgNameWithArgs listy_suffix', [Toke_MsgNameWithArgs]);
        desirables.put('msg -> MsgName', [Toke_MsgName]);
        desirables.put('msg -> listy', [Toke_ListS]);

        // listy_entries
        desirables.put('listy_entries -> skoaroid moar_listy_entries', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);

        // assignment
        desirables.put('assignment -> AssOp settable', [Toke_AssOp]);

        // nouny_literal
        desirables.put('nouny_literal -> Tuplet', [Toke_Tuplet]);
        desirables.put('nouny_literal -> Caesura', [Toke_Caesura]);
        desirables.put('nouny_literal -> Slur', [Toke_Slur]);
        desirables.put('nouny_literal -> Int', [Toke_Int]);
        desirables.put('nouny_literal -> Float', [Toke_Float]);
        desirables.put('nouny_literal -> String', [Toke_String]);
        desirables.put('nouny_literal -> Choard', [Toke_Choard]);
        desirables.put('nouny_literal -> NamedNoat', [Toke_NamedNoat]);
        desirables.put('nouny_literal -> Symbol', [Toke_Symbol]);
        desirables.put('nouny_literal -> CurNoat', [Toke_CurNoat]);

        // skrp_suffix
        desirables.put('skrp_suffix -> skrp_lines SkoarpionEnd', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_Quavers, Toke_Carrot,
                   Toke_CurNoat, Toke_Rep, Toke_DaCapo, Toke_DynSFZ, Toke_DynPiano,
                   Toke_Caesura, Toke_Loco, Toke_Coda, Toke_Bars, Toke_OttavaA,
                   Toke_Volta, Toke_Symbol, Toke_SeqRef, Toke_Crotchets, Toke_DalSegno,
                   Toke_Slur, Toke_DynForte, Toke_Quarters, Toke_Eighths, Toke_PedalDown,
                   Toke_Segno, Toke_LWing, Toke_Slash, Toke_QuindicesimaB, Toke_Int,
                   Toke_SkoarpionSep, Toke_QuindicesimaA, Toke_Voice, Toke_Fine, Toke_CondS,
                   Toke_Meter, Toke_String, Toke_Choard, Toke_SkoarpionEnd, Toke_NamedNoat,
                   Toke_Newline, Toke_ListS, Toke_SkoarpionStart, Toke_Tuplet, Toke_Comment,
                   Toke_Float, Toke_DynFP, Toke_OctaveShift]);

        // skoaroid
        desirables.put('skoaroid -> nouny msg_chain_node', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);

        // branch
        desirables.put('branch -> optional_voice phrases Newline', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_Quavers, Toke_Carrot,
                   Toke_CurNoat, Toke_Rep, Toke_DaCapo, Toke_DynSFZ, Toke_DynPiano,
                   Toke_Caesura, Toke_Loco, Toke_Coda, Toke_Bars, Toke_OttavaA,
                   Toke_Volta, Toke_Symbol, Toke_SeqRef, Toke_Crotchets, Toke_DalSegno,
                   Toke_Slur, Toke_DynForte, Toke_Quarters, Toke_Eighths, Toke_PedalDown,
                   Toke_Segno, Toke_LWing, Toke_Slash, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_Fine, Toke_Voice, Toke_CondS, Toke_Meter,
                   Toke_String, Toke_Choard, Toke_NamedNoat, Toke_Newline, Toke_ListS,
                   Toke_SkoarpionStart, Toke_Tuplet, Toke_Comment, Toke_Float, Toke_DynFP,
                   Toke_OctaveShift]);

        // boolean
        desirables.put('boolean -> skoaroid BooleanOp skoaroid', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);

        // phrasey
        desirables.put('phrasey -> Comment', [Toke_Comment]);
        desirables.put('phrasey -> marker', [Toke_Coda, Toke_Volta, Toke_Fine, Toke_Bars, Toke_Segno]);
        desirables.put('phrasey -> Meter', [Toke_Meter]);
        desirables.put('phrasey -> stmt', [Toke_OttavaB, Toke_PedalUp, Toke_Portamento, Toke_QuindicesimaB, Toke_Int,
                   Toke_QuindicesimaA, Toke_CurNoat, Toke_Rep, Toke_Carrot, Toke_CondS,
                   Toke_DynSFZ, Toke_String, Toke_DynPiano, Toke_Caesura, Toke_Choard,
                   Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_ListS, Toke_Symbol,
                   Toke_SeqRef, Toke_SkoarpionStart, Toke_Slur, Toke_DynForte, Toke_Tuplet,
                   Toke_PedalDown, Toke_Float, Toke_DynFP, Toke_LWing, Toke_OctaveShift]);
        desirables.put('phrasey -> dal_goto', [Toke_DalSegno, Toke_DaCapo]);
        desirables.put('phrasey -> beat', [Toke_Eighths, Toke_Quavers, Toke_Quarters, Toke_Slash, Toke_Crotchets]);

        // nouny
        desirables.put('nouny -> cthulhu', [Toke_LWing]);
        desirables.put('nouny -> conditional', [Toke_CondS]);
        desirables.put('nouny -> nouny_literal', [Toke_Int, Toke_Symbol, Toke_CurNoat, Toke_Slur, Toke_Tuplet,
                   Toke_String, Toke_Choard, Toke_Caesura, Toke_Float, Toke_NamedNoat]);
        desirables.put('nouny -> musical_keyword', [Toke_OttavaB, Toke_QuindicesimaA, Toke_Portamento, Toke_QuindicesimaB, Toke_PedalUp,
                   Toke_Rep, Toke_Carrot, Toke_DynForte, Toke_DynSFZ, Toke_DynPiano,
                   Toke_PedalDown, Toke_DynFP, Toke_Loco, Toke_OctaveShift, Toke_OttavaA]);
        desirables.put('nouny -> listy', [Toke_ListS]);
        desirables.put('nouny -> seq_ref', [Toke_SeqRef]);
        desirables.put('nouny -> skoarpion', [Toke_SkoarpionStart]);

        // seq_ref
        desirables.put('seq_ref -> SeqRef seq_ref_prime', [Toke_SeqRef]);

        // settable
        desirables.put('settable -> Caesura', [Toke_Caesura]);
        desirables.put('settable -> CurNoat', [Toke_CurNoat]);
        desirables.put('settable -> Symbol', [Toke_Symbol]);
        desirables.put('settable -> listy', [Toke_ListS]);
        desirables.put('settable -> Quarters', [Toke_Quarters]);
        desirables.put('settable -> Eighths', [Toke_Eighths]);

        // skrp_moar_lines
        desirables.put('skrp_moar_lines -> skrp_sep_or_nl skrp_lines', [Toke_Newline, Toke_SkoarpionSep]);
    }

    seq_ref_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['seq_ref_prime -> MsgNameWithArgs listy_suffix'];
        // seq_ref_prime -> MsgNameWithArgs listy_suffix
        if (toker.sees(desires) != nil) {
            "seq_ref_prime -> MsgNameWithArgs listy_suffix
".post;
            noad.add_toke("Toke_MsgNameWithArgs", toker.burn(Toke_MsgNameWithArgs));
            "burning: MsgNameWithArgs
".post;
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['seq_ref_prime -> MsgName'];
        // seq_ref_prime -> MsgName
        if (toker.sees(desires) != nil) {
            "seq_ref_prime -> MsgName
".post;
            noad.add_toke("Toke_MsgName", toker.burn(Toke_MsgName));
            "burning: MsgName
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    moar_args_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['moar_args_entries -> ListSep args_entries'];
        // moar_args_entries -> ListSep args_entries
        if (toker.sees(desires) != nil) {
            "moar_args_entries -> ListSep args_entries
".post;
            noad.add_toke("Toke_ListSep", toker.burn(Toke_ListSep));
            "burning: ListSep
".post;
            this.args_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    args {
        | parent |

        var noad = SkoarNoad.new("args", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['args -> ListS args_suffix'];
        // args -> ListS args_suffix
        if (toker.sees(desires) != nil) {
            "args -> ListS args_suffix
".post;
            noad.add_toke("Toke_ListS", toker.burn(Toke_ListS));
            "burning: ListS
".post;
            this.args_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoarpion {
        | parent |

        var noad = SkoarNoad.new("skoarpion", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix'];
        // skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix
        if (toker.sees(desires) != nil) {
            "skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix
".post;
            noad.add_toke("Toke_SkoarpionStart", toker.burn(Toke_SkoarpionStart));
            "burning: SkoarpionStart
".post;
            noad.add_noad(this.skrp_sig(noad));
            noad.add_toke("Toke_SkoarpionSep", toker.burn(Toke_SkoarpionSep));
            "burning: SkoarpionSep
".post;
            noad.add_noad(this.skrp_suffix(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    musical_keyword_misc {
        | parent |

        var noad = SkoarNoad.new("musical_keyword_misc", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['musical_keyword_misc -> Rep'];
        // musical_keyword_misc -> Rep
        if (toker.sees(desires) != nil) {
            "musical_keyword_misc -> Rep
".post;
            noad.add_toke("Toke_Rep", toker.burn(Toke_Rep));
            "burning: Rep
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['musical_keyword_misc -> Portamento'];
        // musical_keyword_misc -> Portamento
        if (toker.sees(desires) != nil) {
            "musical_keyword_misc -> Portamento
".post;
            noad.add_toke("Toke_Portamento", toker.burn(Toke_Portamento));
            "burning: Portamento
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['musical_keyword_misc -> Carrot'];
        // musical_keyword_misc -> Carrot
        if (toker.sees(desires) != nil) {
            "musical_keyword_misc -> Carrot
".post;
            noad.add_toke("Toke_Carrot", toker.burn(Toke_Carrot));
            "burning: Carrot
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    stmt_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['stmt_prime -> assignment stmt_prime'];
        // stmt_prime -> assignment stmt_prime
        if (toker.sees(desires) != nil) {
            "stmt_prime -> assignment stmt_prime
".post;
            noad.add_noad(this.assignment(noad));
            this.stmt_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    al_x {
        | parent |

        var noad = SkoarNoad.new("al_x", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['al_x -> AlCoda'];
        // al_x -> AlCoda
        if (toker.sees(desires) != nil) {
            "al_x -> AlCoda
".post;
            noad.add_toke("Toke_AlCoda", toker.burn(Toke_AlCoda));
            "burning: AlCoda
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['al_x -> AlSegno'];
        // al_x -> AlSegno
        if (toker.sees(desires) != nil) {
            "al_x -> AlSegno
".post;
            noad.add_toke("Toke_AlSegno", toker.burn(Toke_AlSegno));
            "burning: AlSegno
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['al_x -> AlFine'];
        // al_x -> AlFine
        if (toker.sees(desires) != nil) {
            "al_x -> AlFine
".post;
            noad.add_toke("Toke_AlFine", toker.burn(Toke_AlFine));
            "burning: AlFine
".post;
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    optional_voice {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['optional_voice -> Voice'];
        // optional_voice -> Voice
        if (toker.sees(desires) != nil) {
            "optional_voice -> Voice
".post;
            noad.add_toke("Toke_Voice", toker.burn(Toke_Voice));
            "burning: Voice
".post;
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    listy {
        | parent |

        var noad = SkoarNoad.new("listy", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['listy -> ListS listy_suffix'];
        // listy -> ListS listy_suffix
        if (toker.sees(desires) != nil) {
            "listy -> ListS listy_suffix
".post;
            noad.add_toke("Toke_ListS", toker.burn(Toke_ListS));
            "burning: ListS
".post;
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    marker {
        | parent |

        var noad = SkoarNoad.new("marker", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['marker -> Segno'];
        // marker -> Segno
        if (toker.sees(desires) != nil) {
            "marker -> Segno
".post;
            noad.add_toke("Toke_Segno", toker.burn(Toke_Segno));
            "burning: Segno
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['marker -> Fine'];
        // marker -> Fine
        if (toker.sees(desires) != nil) {
            "marker -> Fine
".post;
            noad.add_toke("Toke_Fine", toker.burn(Toke_Fine));
            "burning: Fine
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['marker -> coda'];
        // marker -> coda
        if (toker.sees(desires) != nil) {
            "marker -> coda
".post;
            noad.add_noad(this.coda(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['marker -> Volta'];
        // marker -> Volta
        if (toker.sees(desires) != nil) {
            "marker -> Volta
".post;
            noad.add_toke("Toke_Volta", toker.burn(Toke_Volta));
            "burning: Volta
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['marker -> Bars'];
        // marker -> Bars
        if (toker.sees(desires) != nil) {
            "marker -> Bars
".post;
            noad.add_toke("Toke_Bars", toker.burn(Toke_Bars));
            "burning: Bars
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    msg_chain_node {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['msg_chain_node -> MsgOp msg msg_chain_node'];
        // msg_chain_node -> MsgOp msg msg_chain_node
        if (toker.sees(desires) != nil) {
            "msg_chain_node -> MsgOp msg msg_chain_node
".post;
            noad.add_toke("Toke_MsgOp", toker.burn(Toke_MsgOp));
            "burning: MsgOp
".post;
            noad.add_noad(this.msg(noad));
            this.msg_chain_node(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    dynamic {
        | parent |

        var noad = SkoarNoad.new("dynamic", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['dynamic -> DynPiano'];
        // dynamic -> DynPiano
        if (toker.sees(desires) != nil) {
            "dynamic -> DynPiano
".post;
            noad.add_toke("Toke_DynPiano", toker.burn(Toke_DynPiano));
            "burning: DynPiano
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['dynamic -> DynForte'];
        // dynamic -> DynForte
        if (toker.sees(desires) != nil) {
            "dynamic -> DynForte
".post;
            noad.add_toke("Toke_DynForte", toker.burn(Toke_DynForte));
            "burning: DynForte
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['dynamic -> DynSFZ'];
        // dynamic -> DynSFZ
        if (toker.sees(desires) != nil) {
            "dynamic -> DynSFZ
".post;
            noad.add_toke("Toke_DynSFZ", toker.burn(Toke_DynSFZ));
            "burning: DynSFZ
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['dynamic -> DynFP'];
        // dynamic -> DynFP
        if (toker.sees(desires) != nil) {
            "dynamic -> DynFP
".post;
            noad.add_toke("Toke_DynFP", toker.burn(Toke_DynFP));
            "burning: DynFP
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_stmt {
        | parent |

        var noad = SkoarNoad.new("optional_stmt", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['optional_stmt -> stmt'];
        // optional_stmt -> stmt
        if (toker.sees(desires) != nil) {
            "optional_stmt -> stmt
".post;
            noad.add_noad(this.stmt(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['optional_stmt -> Newline'];
        // optional_stmt -> Newline
        if (toker.sees(desires) != nil) {
            "optional_stmt -> Newline
".post;
            noad.add_toke("Toke_Newline", toker.burn(Toke_Newline));
            "burning: Newline
".post;
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    args_suffix {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['args_suffix -> args_entries ListE'];
        // args_suffix -> args_entries ListE
        if (toker.sees(desires) != nil) {
            "args_suffix -> args_entries ListE
".post;
            this.args_entries(noad);
            noad.add_toke("Toke_ListE", toker.burn(Toke_ListE));
            "burning: ListE
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    stmt {
        | parent |

        var noad = SkoarNoad.new("stmt", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['stmt -> skoaroid stmt_prime'];
        // stmt -> skoaroid stmt_prime
        if (toker.sees(desires) != nil) {
            "stmt -> skoaroid stmt_prime
".post;
            noad.add_noad(this.skoaroid(noad));
            this.stmt_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy_suffix {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['listy_suffix -> listy_entries ListE'];
        // listy_suffix -> listy_entries ListE
        if (toker.sees(desires) != nil) {
            "listy_suffix -> listy_entries ListE
".post;
            this.listy_entries(noad);
            noad.add_toke("Toke_ListE", toker.burn(Toke_ListE));
            "burning: ListE
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['listy_suffix -> ListE'];
        // listy_suffix -> ListE
        if (toker.sees(desires) != nil) {
            "listy_suffix -> ListE
".post;
            noad.add_toke("Toke_ListE", toker.burn(Toke_ListE));
            "burning: ListE
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    args_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['args_entries -> SymbolName moar_args_entries'];
        // args_entries -> SymbolName moar_args_entries
        if (toker.sees(desires) != nil) {
            "args_entries -> SymbolName moar_args_entries
".post;
            noad.add_toke("Toke_SymbolName", toker.burn(Toke_SymbolName));
            "burning: SymbolName
".post;
            this.moar_args_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    cthulhu {
        | parent |

        var noad = SkoarNoad.new("cthulhu", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['cthulhu -> LWing CondSep cthulhu_prime'];
        // cthulhu -> LWing CondSep cthulhu_prime
        if (toker.sees(desires) != nil) {
            "cthulhu -> LWing CondSep cthulhu_prime
".post;
            noad.add_toke("Toke_LWing", toker.burn(Toke_LWing));
            "burning: LWing
".post;
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            "burning: CondSep
".post;
            this.cthulhu_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    conditional {
        | parent |

        var noad = SkoarNoad.new("conditional", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE'];
        // conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE
        if (toker.sees(desires) != nil) {
            "conditional -> CondS optional_stmt CondSep boolean CondSep optional_stmt CondE
".post;
            noad.add_toke("Toke_CondS", toker.burn(Toke_CondS));
            "burning: CondS
".post;
            noad.add_noad(this.optional_stmt(noad));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            "burning: CondSep
".post;
            noad.add_noad(this.boolean(noad));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            "burning: CondSep
".post;
            noad.add_noad(this.optional_stmt(noad));
            noad.add_toke("Toke_CondE", toker.burn(Toke_CondE));
            "burning: CondE
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    beat {
        | parent |

        var noad = SkoarNoad.new("beat", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['beat -> Crotchets'];
        // beat -> Crotchets
        if (toker.sees(desires) != nil) {
            "beat -> Crotchets
".post;
            noad.add_toke("Toke_Crotchets", toker.burn(Toke_Crotchets));
            "burning: Crotchets
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['beat -> Quavers'];
        // beat -> Quavers
        if (toker.sees(desires) != nil) {
            "beat -> Quavers
".post;
            noad.add_toke("Toke_Quavers", toker.burn(Toke_Quavers));
            "burning: Quavers
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['beat -> Quarters'];
        // beat -> Quarters
        if (toker.sees(desires) != nil) {
            "beat -> Quarters
".post;
            noad.add_toke("Toke_Quarters", toker.burn(Toke_Quarters));
            "burning: Quarters
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['beat -> Eighths'];
        // beat -> Eighths
        if (toker.sees(desires) != nil) {
            "beat -> Eighths
".post;
            noad.add_toke("Toke_Eighths", toker.burn(Toke_Eighths));
            "burning: Eighths
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['beat -> Slash'];
        // beat -> Slash
        if (toker.sees(desires) != nil) {
            "beat -> Slash
".post;
            noad.add_toke("Toke_Slash", toker.burn(Toke_Slash));
            "burning: Slash
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_sig {
        | parent |

        var noad = SkoarNoad.new("skrp_sig", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skrp_sig -> args'];
        // skrp_sig -> args
        if (toker.sees(desires) != nil) {
            "skrp_sig -> args
".post;
            noad.add_noad(this.args(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['skrp_sig -> SymbolName optional_args'];
        // skrp_sig -> SymbolName optional_args
        if (toker.sees(desires) != nil) {
            "skrp_sig -> SymbolName optional_args
".post;
            noad.add_toke("Toke_SymbolName", toker.burn(Toke_SymbolName));
            "burning: SymbolName
".post;
            this.optional_args(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    optional_args {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['optional_args -> args'];
        // optional_args -> args
        if (toker.sees(desires) != nil) {
            "optional_args -> args
".post;
            noad.add_noad(this.args(noad));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    cthulhu_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['cthulhu_prime -> boolean CondSep RWing'];
        // cthulhu_prime -> boolean CondSep RWing
        if (toker.sees(desires) != nil) {
            "cthulhu_prime -> boolean CondSep RWing
".post;
            noad.add_noad(this.boolean(noad));
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            "burning: CondSep
".post;
            noad.add_toke("Toke_RWing", toker.burn(Toke_RWing));
            "burning: RWing
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['cthulhu_prime -> Nosey CondSep RWing'];
        // cthulhu_prime -> Nosey CondSep RWing
        if (toker.sees(desires) != nil) {
            "cthulhu_prime -> Nosey CondSep RWing
".post;
            noad.add_toke("Toke_Nosey", toker.burn(Toke_Nosey));
            "burning: Nosey
".post;
            noad.add_toke("Toke_CondSep", toker.burn(Toke_CondSep));
            "burning: CondSep
".post;
            noad.add_toke("Toke_RWing", toker.burn(Toke_RWing));
            "burning: RWing
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    musical_keyword {
        | parent |

        var noad = SkoarNoad.new("musical_keyword", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['musical_keyword -> dynamic'];
        // musical_keyword -> dynamic
        if (toker.sees(desires) != nil) {
            "musical_keyword -> dynamic
".post;
            noad.add_noad(this.dynamic(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['musical_keyword -> ottavas'];
        // musical_keyword -> ottavas
        if (toker.sees(desires) != nil) {
            "musical_keyword -> ottavas
".post;
            noad.add_noad(this.ottavas(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['musical_keyword -> pedally'];
        // musical_keyword -> pedally
        if (toker.sees(desires) != nil) {
            "musical_keyword -> pedally
".post;
            noad.add_noad(this.pedally(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['musical_keyword -> musical_keyword_misc'];
        // musical_keyword -> musical_keyword_misc
        if (toker.sees(desires) != nil) {
            "musical_keyword -> musical_keyword_misc
".post;
            noad.add_noad(this.musical_keyword_misc(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_sep_or_nl {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skrp_sep_or_nl -> Newline'];
        // skrp_sep_or_nl -> Newline
        if (toker.sees(desires) != nil) {
            "skrp_sep_or_nl -> Newline
".post;
            noad.add_toke("Toke_Newline", toker.burn(Toke_Newline));
            "burning: Newline
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['skrp_sep_or_nl -> SkoarpionSep'];
        // skrp_sep_or_nl -> SkoarpionSep
        if (toker.sees(desires) != nil) {
            "skrp_sep_or_nl -> SkoarpionSep
".post;
            noad.add_toke("Toke_SkoarpionSep", toker.burn(Toke_SkoarpionSep));
            "burning: SkoarpionSep
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    branches {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['branches -> branch branches'];
        // branches -> branch branches
        if (toker.sees(desires) != nil) {
            "branches -> branch branches
".post;
            noad.add_noad(this.branch(noad));
            this.branches(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    optional_al_coda {
        | parent |

        var noad = SkoarNoad.new("optional_al_coda", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['optional_al_coda -> AlCoda'];
        // optional_al_coda -> AlCoda
        if (toker.sees(desires) != nil) {
            "optional_al_coda -> AlCoda
".post;
            noad.add_toke("Toke_AlCoda", toker.burn(Toke_AlCoda));
            "burning: AlCoda
".post;
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    skrp_lines {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skrp_lines -> optional_voice phrases skrp_moar_lines'];
        // skrp_lines -> optional_voice phrases skrp_moar_lines
        if (toker.sees(desires) != nil) {
            "skrp_lines -> optional_voice phrases skrp_moar_lines
".post;
            this.optional_voice(noad);
            this.phrases(noad);
            this.skrp_moar_lines(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoar {
        | parent |

        var noad = SkoarNoad.new("skoar", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skoar -> branches'];
        // skoar -> branches
        if (toker.sees(desires) != nil) {
            "skoar -> branches
".post;
            this.branches(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    pedally {
        | parent |

        var noad = SkoarNoad.new("pedally", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['pedally -> PedalDown'];
        // pedally -> PedalDown
        if (toker.sees(desires) != nil) {
            "pedally -> PedalDown
".post;
            noad.add_toke("Toke_PedalDown", toker.burn(Toke_PedalDown));
            "burning: PedalDown
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['pedally -> PedalUp'];
        // pedally -> PedalUp
        if (toker.sees(desires) != nil) {
            "pedally -> PedalUp
".post;
            noad.add_toke("Toke_PedalUp", toker.burn(Toke_PedalUp));
            "burning: PedalUp
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    coda {
        | parent |

        var noad = SkoarNoad.new("coda", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['coda -> Coda optional_al_coda'];
        // coda -> Coda optional_al_coda
        if (toker.sees(desires) != nil) {
            "coda -> Coda optional_al_coda
".post;
            noad.add_toke("Toke_Coda", toker.burn(Toke_Coda));
            "burning: Coda
".post;
            noad.add_noad(this.optional_al_coda(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    dal_goto {
        | parent |

        var noad = SkoarNoad.new("dal_goto", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['dal_goto -> DaCapo al_x'];
        // dal_goto -> DaCapo al_x
        if (toker.sees(desires) != nil) {
            "dal_goto -> DaCapo al_x
".post;
            noad.add_toke("Toke_DaCapo", toker.burn(Toke_DaCapo));
            "burning: DaCapo
".post;
            noad.add_noad(this.al_x(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['dal_goto -> DalSegno al_x'];
        // dal_goto -> DalSegno al_x
        if (toker.sees(desires) != nil) {
            "dal_goto -> DalSegno al_x
".post;
            noad.add_toke("Toke_DalSegno", toker.burn(Toke_DalSegno));
            "burning: DalSegno
".post;
            noad.add_noad(this.al_x(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    moar_listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['moar_listy_entries -> ListSep listy_entries'];
        // moar_listy_entries -> ListSep listy_entries
        if (toker.sees(desires) != nil) {
            "moar_listy_entries -> ListSep listy_entries
".post;
            noad.add_toke("Toke_ListSep", toker.burn(Toke_ListSep));
            "burning: ListSep
".post;
            this.listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['moar_listy_entries -> Newline'];
        // moar_listy_entries -> Newline
        if (toker.sees(desires) != nil) {
            "moar_listy_entries -> Newline
".post;
            noad.add_toke("Toke_Newline", toker.burn(Toke_Newline));
            "burning: Newline
".post;
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    phrases {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['phrases -> phrasey phrases'];
        // phrases -> phrasey phrases
        if (toker.sees(desires) != nil) {
            "phrases -> phrasey phrases
".post;
            this.phrasey(noad);
            this.phrases(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

    ottavas {
        | parent |

        var noad = SkoarNoad.new("ottavas", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['ottavas -> OctaveShift'];
        // ottavas -> OctaveShift
        if (toker.sees(desires) != nil) {
            "ottavas -> OctaveShift
".post;
            noad.add_toke("Toke_OctaveShift", toker.burn(Toke_OctaveShift));
            "burning: OctaveShift
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['ottavas -> OttavaA'];
        // ottavas -> OttavaA
        if (toker.sees(desires) != nil) {
            "ottavas -> OttavaA
".post;
            noad.add_toke("Toke_OttavaA", toker.burn(Toke_OttavaA));
            "burning: OttavaA
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['ottavas -> OttavaB'];
        // ottavas -> OttavaB
        if (toker.sees(desires) != nil) {
            "ottavas -> OttavaB
".post;
            noad.add_toke("Toke_OttavaB", toker.burn(Toke_OttavaB));
            "burning: OttavaB
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['ottavas -> QuindicesimaA'];
        // ottavas -> QuindicesimaA
        if (toker.sees(desires) != nil) {
            "ottavas -> QuindicesimaA
".post;
            noad.add_toke("Toke_QuindicesimaA", toker.burn(Toke_QuindicesimaA));
            "burning: QuindicesimaA
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['ottavas -> QuindicesimaB'];
        // ottavas -> QuindicesimaB
        if (toker.sees(desires) != nil) {
            "ottavas -> QuindicesimaB
".post;
            noad.add_toke("Toke_QuindicesimaB", toker.burn(Toke_QuindicesimaB));
            "burning: QuindicesimaB
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['ottavas -> Loco'];
        // ottavas -> Loco
        if (toker.sees(desires) != nil) {
            "ottavas -> Loco
".post;
            noad.add_toke("Toke_Loco", toker.burn(Toke_Loco));
            "burning: Loco
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    msg {
        | parent |

        var noad = SkoarNoad.new("msg", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['msg -> MsgNameWithArgs listy_suffix'];
        // msg -> MsgNameWithArgs listy_suffix
        if (toker.sees(desires) != nil) {
            "msg -> MsgNameWithArgs listy_suffix
".post;
            noad.add_toke("Toke_MsgNameWithArgs", toker.burn(Toke_MsgNameWithArgs));
            "burning: MsgNameWithArgs
".post;
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['msg -> MsgName'];
        // msg -> MsgName
        if (toker.sees(desires) != nil) {
            "msg -> MsgName
".post;
            noad.add_toke("Toke_MsgName", toker.burn(Toke_MsgName));
            "burning: MsgName
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['msg -> listy'];
        // msg -> listy
        if (toker.sees(desires) != nil) {
            "msg -> listy
".post;
            noad.add_noad(this.listy(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['listy_entries -> skoaroid moar_listy_entries'];
        // listy_entries -> skoaroid moar_listy_entries
        if (toker.sees(desires) != nil) {
            "listy_entries -> skoaroid moar_listy_entries
".post;
            noad.add_noad(this.skoaroid(noad));
            this.moar_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    assignment {
        | parent |

        var noad = SkoarNoad.new("assignment", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['assignment -> AssOp settable'];
        // assignment -> AssOp settable
        if (toker.sees(desires) != nil) {
            "assignment -> AssOp settable
".post;
            noad.add_toke("Toke_AssOp", toker.burn(Toke_AssOp));
            "burning: AssOp
".post;
            this.settable(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    nouny_literal {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['nouny_literal -> Tuplet'];
        // nouny_literal -> Tuplet
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Tuplet
".post;
            noad.add_toke("Toke_Tuplet", toker.burn(Toke_Tuplet));
            "burning: Tuplet
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> Caesura'];
        // nouny_literal -> Caesura
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Caesura
".post;
            noad.add_toke("Toke_Caesura", toker.burn(Toke_Caesura));
            "burning: Caesura
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> Slur'];
        // nouny_literal -> Slur
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Slur
".post;
            noad.add_toke("Toke_Slur", toker.burn(Toke_Slur));
            "burning: Slur
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> Int'];
        // nouny_literal -> Int
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Int
".post;
            noad.add_toke("Toke_Int", toker.burn(Toke_Int));
            "burning: Int
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> Float'];
        // nouny_literal -> Float
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Float
".post;
            noad.add_toke("Toke_Float", toker.burn(Toke_Float));
            "burning: Float
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> String'];
        // nouny_literal -> String
        if (toker.sees(desires) != nil) {
            "nouny_literal -> String
".post;
            noad.add_toke("Toke_String", toker.burn(Toke_String));
            "burning: String
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> Choard'];
        // nouny_literal -> Choard
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Choard
".post;
            noad.add_toke("Toke_Choard", toker.burn(Toke_Choard));
            "burning: Choard
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> NamedNoat'];
        // nouny_literal -> NamedNoat
        if (toker.sees(desires) != nil) {
            "nouny_literal -> NamedNoat
".post;
            noad.add_toke("Toke_NamedNoat", toker.burn(Toke_NamedNoat));
            "burning: NamedNoat
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> Symbol'];
        // nouny_literal -> Symbol
        if (toker.sees(desires) != nil) {
            "nouny_literal -> Symbol
".post;
            noad.add_toke("Toke_Symbol", toker.burn(Toke_Symbol));
            "burning: Symbol
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny_literal -> CurNoat'];
        // nouny_literal -> CurNoat
        if (toker.sees(desires) != nil) {
            "nouny_literal -> CurNoat
".post;
            noad.add_toke("Toke_CurNoat", toker.burn(Toke_CurNoat));
            "burning: CurNoat
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_suffix {
        | parent |

        var noad = SkoarNoad.new("skrp_suffix", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skrp_suffix -> skrp_lines SkoarpionEnd'];
        // skrp_suffix -> skrp_lines SkoarpionEnd
        if (toker.sees(desires) != nil) {
            "skrp_suffix -> skrp_lines SkoarpionEnd
".post;
            this.skrp_lines(noad);
            noad.add_toke("Toke_SkoarpionEnd", toker.burn(Toke_SkoarpionEnd));
            "burning: SkoarpionEnd
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoaroid {
        | parent |

        var noad = SkoarNoad.new("skoaroid", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skoaroid -> nouny msg_chain_node'];
        // skoaroid -> nouny msg_chain_node
        if (toker.sees(desires) != nil) {
            "skoaroid -> nouny msg_chain_node
".post;
            noad.add_noad(this.nouny(noad));
            this.msg_chain_node(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    branch {
        | parent |

        var noad = SkoarNoad.new("branch", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['branch -> optional_voice phrases Newline'];
        // branch -> optional_voice phrases Newline
        if (toker.sees(desires) != nil) {
            "branch -> optional_voice phrases Newline
".post;
            this.optional_voice(noad);
            this.phrases(noad);
            noad.add_toke("Toke_Newline", toker.burn(Toke_Newline));
            "burning: Newline
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    boolean {
        | parent |

        var noad = SkoarNoad.new("boolean", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['boolean -> skoaroid BooleanOp skoaroid'];
        // boolean -> skoaroid BooleanOp skoaroid
        if (toker.sees(desires) != nil) {
            "boolean -> skoaroid BooleanOp skoaroid
".post;
            noad.add_noad(this.skoaroid(noad));
            noad.add_toke("Toke_BooleanOp", toker.burn(Toke_BooleanOp));
            "burning: BooleanOp
".post;
            noad.add_noad(this.skoaroid(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    phrasey {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['phrasey -> Comment'];
        // phrasey -> Comment
        if (toker.sees(desires) != nil) {
            "phrasey -> Comment
".post;
            noad.add_toke("Toke_Comment", toker.burn(Toke_Comment));
            "burning: Comment
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['phrasey -> marker'];
        // phrasey -> marker
        if (toker.sees(desires) != nil) {
            "phrasey -> marker
".post;
            noad.add_noad(this.marker(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['phrasey -> Meter'];
        // phrasey -> Meter
        if (toker.sees(desires) != nil) {
            "phrasey -> Meter
".post;
            noad.add_toke("Toke_Meter", toker.burn(Toke_Meter));
            "burning: Meter
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['phrasey -> stmt'];
        // phrasey -> stmt
        if (toker.sees(desires) != nil) {
            "phrasey -> stmt
".post;
            noad.add_noad(this.stmt(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['phrasey -> dal_goto'];
        // phrasey -> dal_goto
        if (toker.sees(desires) != nil) {
            "phrasey -> dal_goto
".post;
            noad.add_noad(this.dal_goto(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['phrasey -> beat'];
        // phrasey -> beat
        if (toker.sees(desires) != nil) {
            "phrasey -> beat
".post;
            noad.add_noad(this.beat(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    nouny {
        | parent |

        var noad = SkoarNoad.new("nouny", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['nouny -> cthulhu'];
        // nouny -> cthulhu
        if (toker.sees(desires) != nil) {
            "nouny -> cthulhu
".post;
            noad.add_noad(this.cthulhu(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny -> conditional'];
        // nouny -> conditional
        if (toker.sees(desires) != nil) {
            "nouny -> conditional
".post;
            noad.add_noad(this.conditional(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny -> nouny_literal'];
        // nouny -> nouny_literal
        if (toker.sees(desires) != nil) {
            "nouny -> nouny_literal
".post;
            this.nouny_literal(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny -> musical_keyword'];
        // nouny -> musical_keyword
        if (toker.sees(desires) != nil) {
            "nouny -> musical_keyword
".post;
            noad.add_noad(this.musical_keyword(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny -> listy'];
        // nouny -> listy
        if (toker.sees(desires) != nil) {
            "nouny -> listy
".post;
            noad.add_noad(this.listy(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny -> seq_ref'];
        // nouny -> seq_ref
        if (toker.sees(desires) != nil) {
            "nouny -> seq_ref
".post;
            noad.add_noad(this.seq_ref(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['nouny -> skoarpion'];
        // nouny -> skoarpion
        if (toker.sees(desires) != nil) {
            "nouny -> skoarpion
".post;
            noad.add_noad(this.skoarpion(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    seq_ref {
        | parent |

        var noad = SkoarNoad.new("seq_ref", parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['seq_ref -> SeqRef seq_ref_prime'];
        // seq_ref -> SeqRef seq_ref_prime
        if (toker.sees(desires) != nil) {
            "seq_ref -> SeqRef seq_ref_prime
".post;
            noad.add_toke("Toke_SeqRef", toker.burn(Toke_SeqRef));
            "burning: SeqRef
".post;
            this.seq_ref_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    settable {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['settable -> Caesura'];
        // settable -> Caesura
        if (toker.sees(desires) != nil) {
            "settable -> Caesura
".post;
            noad.add_toke("Toke_Caesura", toker.burn(Toke_Caesura));
            "burning: Caesura
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['settable -> CurNoat'];
        // settable -> CurNoat
        if (toker.sees(desires) != nil) {
            "settable -> CurNoat
".post;
            noad.add_toke("Toke_CurNoat", toker.burn(Toke_CurNoat));
            "burning: CurNoat
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['settable -> Symbol'];
        // settable -> Symbol
        if (toker.sees(desires) != nil) {
            "settable -> Symbol
".post;
            noad.add_toke("Toke_Symbol", toker.burn(Toke_Symbol));
            "burning: Symbol
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['settable -> listy'];
        // settable -> listy
        if (toker.sees(desires) != nil) {
            "settable -> listy
".post;
            noad.add_noad(this.listy(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['settable -> Quarters'];
        // settable -> Quarters
        if (toker.sees(desires) != nil) {
            "settable -> Quarters
".post;
            noad.add_toke("Toke_Quarters", toker.burn(Toke_Quarters));
            "burning: Quarters
".post;
            deep = deep - 1;
            ^noad;
        };

        desires = desirables['settable -> Eighths'];
        // settable -> Eighths
        if (toker.sees(desires) != nil) {
            "settable -> Eighths
".post;
            noad.add_toke("Toke_Eighths", toker.burn(Toke_Eighths));
            "burning: Eighths
".post;
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_moar_lines {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 100) {
            this.fail_too_deep;
        };

        desires = desirables['skrp_moar_lines -> skrp_sep_or_nl skrp_lines'];
        // skrp_moar_lines -> skrp_sep_or_nl skrp_lines
        if (toker.sees(desires) != nil) {
            "skrp_moar_lines -> skrp_sep_or_nl skrp_lines
".post;
            this.skrp_sep_or_nl(noad);
            this.skrp_lines(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        "burning empty
".post;
        deep = deep - 1;
        ^noad;
    }

}

