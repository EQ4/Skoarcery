// ================================================================================
// lex.sc - Generated by Code_Sc_Lexer on 2014-11-09 18:32:04 for SuperCollider 3.6
// ================================================================================
// --------------
// SkoarException
// --------------
SkoarError : Exception {
    *new {
        | msg |

        ^super.new(msg);
    }

    *errorString {
        ^"SKOAR" ++ super.errorString;
    }

}

// --------------
// Abstract Token
// --------------
SkoarToke {
    var <lexeme;
    var <>val;
    classvar <regex = nil;

    *new {
        | s |

        ^super.new.init( s );
    }

    init {
        | s |

        lexeme = s;
    }

    // how many characters to burn from the buffer
    burn {
        ^lexeme.size;
    }

    // override and return nil for no match, new toke otherwise
    *match {
        | buf, offs |

        SubclassResponsibilityError("What are you doing human?").throw;
    }

    // match requested toke
    *match_toke {
        | buf, offs, toke_class |

        var match;
        try {
            match = buf.findRegexp(toke_class.regex, offs);
            if (match.size == 0) {
                ^nil;
            };

            if (match[0][0] == offs) {
                ^toke_class.new(match[0][1]);
            };

        } {
            // pass
        }

        ^nil;
    }

}

// ---------------------
// Whitespace is special
// ---------------------
Toke_Whitespace : SkoarToke {
    classvar <regex = "^(?:[ \\t]*)";

    *burn {
        | buf, offs |

        var match;
        try {
            match = buf.findRegexp(Toke_Whitespace.regex, offs);
            if (match[0][0] == offs) {
                ^match[0][1].size;
            };

        } {
            // pass
        }

        ^0;
    }

}

// --------------
// EOF is special
// --------------
Toke_EOF : SkoarToke {
    *burn {
        | buf, offs |

        if (buf.size > offs) {
            SkoarError("Tried to burn EOF when there's more input.").throw;
        };

        ^0;
    }

    *match {
        | buf, offs |

        if (buf.size < offs) {
            SkoarError("Tried to burn EOF when there's more input.").throw;
        };

        if (buf.size == offs) {
            ^Toke_EOF.new();
        };

        ^nil;
    }

}

// --------------
// Everyday Tokes
// --------------
Toke_Quavers : SkoarToke {
    classvar <regex = "^(?:o+/\\.?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Quavers);
    }

}

Toke_MsgOp : SkoarToke {
    classvar <regex = "^(?:\\.(?![)\\]]))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MsgOp);
    }

}

Toke_Coda : SkoarToke {
    classvar <regex = "^(?:\\([+]\\))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Coda);
    }

}

Toke_Symbol : SkoarToke {
    classvar <regex = "^(?:[\\\\@][a-zA-Z_][a-zA-Z0-9_]*)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Symbol);
    }

}

Toke_SkoarpionStart : SkoarToke {
    classvar <regex = "^(?:[{]!)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionStart);
    }

}

Toke_MsgName : SkoarToke {
    classvar <regex = "^(?:[a-zA-Z_][a-zA-Z0-9_]*(?!<))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MsgName);
    }

}

Toke_SkoarpionEnd : SkoarToke {
    classvar <regex = "^(?:![}])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionEnd);
    }

}

Toke_String : SkoarToke {
    classvar <regex = "^(?:'[^']*')";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_String);
    }

}

Toke_CondS : SkoarToke {
    classvar <regex = "^(?:[{][?])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CondS);
    }

}

Toke_CondE : SkoarToke {
    classvar <regex = "^(?:[?][}])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CondE);
    }

}

Toke_Float : SkoarToke {
    classvar <regex = "^(?:(-)?(0|[1-9][0-9]*)\\.[0-9]+)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Float);
    }

}

Toke_MsgNameWithArgs : SkoarToke {
    classvar <regex = "^(?:[a-zA-Z_][a-zA-Z0-9_]*<)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MsgNameWithArgs);
    }

}

Toke_AlCoda : SkoarToke {
    classvar <regex = "^(?:al(la)? coda)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AlCoda);
    }

}

Toke_Segno : SkoarToke {
    classvar <regex = "^(?:,segno`(?:_[a-zA-Z_][a-zA-Z0-9_]*`)*)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Segno);
    }

}

Toke_Fine : SkoarToke {
    classvar <regex = "^(?:fine)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Fine);
    }

}

Toke_LWing : SkoarToke {
    classvar <regex = "^(?:\\^\\^[(])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_LWing);
    }

}

Toke_ListSep : SkoarToke {
    classvar <regex = "^(?:,)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ListSep);
    }

}

Toke_PedalUp : SkoarToke {
    classvar <regex = "^(?:[*])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_PedalUp);
    }

}

Toke_Quarters : SkoarToke {
    classvar <regex = "^(?:\\.?[)]+(?:__)?\\.?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Quarters);
    }

}

Toke_Rep : SkoarToke {
    classvar <regex = "^(?:%+)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Rep);
    }

}

Toke_SymbolName : SkoarToke {
    classvar <regex = "^(?:[a-zA-Z_][a-zA-Z0-9_]*)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SymbolName);
    }

}

Toke_OctaveShift : SkoarToke {
    classvar <regex = "^(?:~+o|o~+)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_OctaveShift);
    }

}

Toke_DynFP : SkoarToke {
    classvar <regex = "^(?:fp)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynFP);
    }

}

Toke_BooleanOp : SkoarToke {
    classvar <regex = "^(?:==|!=|<=|>=|in|nin|and|or|xor)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_BooleanOp);
    }

}

Toke_Slash : SkoarToke {
    classvar <regex = "^(?:/(?!/))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Slash);
    }

}

Toke_QuindicesimaA : SkoarToke {
    classvar <regex = "^(?:15ma|alla quindicesima)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_QuindicesimaA);
    }

}

Toke_NamedNoat : SkoarToke {
    classvar <regex = "^(?:(?:_?)(?:[a-eg]|f(?![ac-zA-Z_]))(#*|b*))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_NamedNoat);
    }

}

Toke_AlFine : SkoarToke {
    classvar <regex = "^(?:al fine)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AlFine);
    }

}

Toke_Carrot : SkoarToke {
    classvar <regex = "^(?:\\^(?!\\^[(]))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Carrot);
    }

}

Toke_AssOp : SkoarToke {
    classvar <regex = "^(?:=>|[+]>|->)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AssOp);
    }

}

Toke_Newline : SkoarToke {
    classvar <regex = "^(?:[\\n\\r\\f]+)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Newline);
    }

}

Toke_CurNoat : SkoarToke {
    classvar <regex = "^(?:[$])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CurNoat);
    }

}

Toke_SkoarpionSep : SkoarToke {
    classvar <regex = "^(?:!!)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionSep);
    }

}

Toke_DalSegno : SkoarToke {
    classvar <regex = "^(?:D\\.S\\.|Dal Segno)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DalSegno);
    }

}

Toke_DynPiano : SkoarToke {
    classvar <regex = "^(?:(mp|p+)(iano)?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynPiano);
    }

}

Toke_OttavaA : SkoarToke {
    classvar <regex = "^(?:8va|ottava (alta|sopra)|all' ottava)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_OttavaA);
    }

}

Toke_Volta : SkoarToke {
    classvar <regex = "^(?:\\[\\d+\\.\\])";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Volta);
    }

}

Toke_Nosey : SkoarToke {
    classvar <regex = "^(?:,)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Nosey);
    }

}

Toke_DynForte : SkoarToke {
    classvar <regex = "^(?:mf(orte)?|f+orte|ff+)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynForte);
    }

}

Toke_Loco : SkoarToke {
    classvar <regex = "^(?:loco)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Loco);
    }

}

Toke_Comment : SkoarToke {
    classvar <regex = "^(?:<[?](.|[\\n\\r\\f])*?[?]>)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Comment);
    }

}

Toke_Caesura : SkoarToke {
    classvar <regex = "^(?://)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Caesura);
    }

}

Toke_ListE : SkoarToke {
    classvar <regex = "^(?:>)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ListE);
    }

}

Toke_Tuplet : SkoarToke {
    classvar <regex = "^(?:/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Tuplet);
    }

}

Toke_ListS : SkoarToke {
    classvar <regex = "^(?:<(?![=?]))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ListS);
    }

}

Toke_RWing : SkoarToke {
    classvar <regex = "^(?:[)]\\^\\^)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_RWing);
    }

}

Toke_CondSep : SkoarToke {
    classvar <regex = "^(?:;)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CondSep);
    }

}

Toke_Meter : SkoarToke {
    classvar <regex = "^(?:[1-9][0-9]*/[1-9][0-9]*)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Meter);
    }

}

Toke_Bars : SkoarToke {
    classvar <regex = "^(?::?\\|+:?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Bars);
    }

}

Toke_Voice : SkoarToke {
    classvar <regex = "^(?:\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Voice);
    }

}

Toke_Choard : SkoarToke {
    classvar <regex = "^(?:(D(?![a.])|[ABCEFG])([Mm0-9]|sus|dim)*)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Choard);
    }

}

Toke_PedalDown : SkoarToke {
    classvar <regex = "^(?:Ped)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_PedalDown);
    }

}

Toke_Crotchets : SkoarToke {
    classvar <regex = "^(?:[}]+\\.?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Crotchets);
    }

}

Toke_AlSegno : SkoarToke {
    classvar <regex = "^(?:al segno)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AlSegno);
    }

}

Toke_DaCapo : SkoarToke {
    classvar <regex = "^(?:D\\.C\\.|Da Capo)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DaCapo);
    }

}

Toke_QuindicesimaB : SkoarToke {
    classvar <regex = "^(?:15mb|alla quindicesimb)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_QuindicesimaB);
    }

}

Toke_DynSFZ : SkoarToke {
    classvar <regex = "^(?:sfz)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynSFZ);
    }

}

Toke_Int : SkoarToke {
    classvar <regex = "^(?:(-)?(0|[1-9][0-9]*)(?![mv][ab]|\\.[0-9]|/))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Int);
    }

}

Toke_Eighths : SkoarToke {
    classvar <regex = "^(?:\\.?\\]+(?:__)?\\.?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Eighths);
    }

}

Toke_Portamento : SkoarToke {
    classvar <regex = "^(?:port\\.?)";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Portamento);
    }

}

Toke_Deref : SkoarToke {
    classvar <regex = "^(?:!(?![!}]))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Deref);
    }

}

Toke_OttavaB : SkoarToke {
    classvar <regex = "^(?:8vb|ottava (bassa|sotto))";

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_OttavaB);
    }

}

