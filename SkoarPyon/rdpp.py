# ==================================================================================================================
# rdpp.py - Generated by PyRDPP - Create Recursive Descent Predictive Parser on 2015-09-04 13:39:53 for Python 3.3.2
# ==================================================================================================================
from Skoarcery.SkoarPyon.apparatus import SkoarNoad
from Skoarcery.SkoarPyon.lex import Toke_QuindicesimaB, Toke_Float, Toke_BooleanOp, Toke_ListE, Toke_Segno, \
    Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_AlFine, Toke_SkoarpionSep, \
    Toke_DynSFZ, Toke_LoopSep, Toke_Volta, Toke_DynForte, Toke_MsgNameWithArgs, \
    Toke_PedalUp, Toke_Rep, Toke_Choard, Toke_Tuplet, Toke_Quarters, \
    Toke_Loco, Toke_NamedNoat, Toke_OttavaA, Toke_DaCapo, Toke_Carrot, \
    Toke_Comment, Toke_AssOp, Toke_Nosey, Toke_CondS, Toke_AlSegno, \
    Toke_String, Toke_QuindicesimaA, Toke_LWing, Toke_Crotchets, Toke_SymbolName, \
    Toke_LoopE, Toke_Newline, Toke_ArgSpec, Toke_Slash, Toke_Fine, \
    Toke_HashLevel, Toke_PedalDown, Toke_DalSegno, Toke_MsgName, Toke_Int, \
    Toke_Fairy, Toke_Voice, Toke_Caesura, Toke_True, Toke_MathOp, \
    Toke_CondIf, Toke_Meter, Toke_Freq, Toke_ListS, Toke_Coda, \
    Toke_Quavers, Toke_Eighths, Toke_OttavaB, Toke_Symbol, Toke_CondE, \
    Toke_Bars, Toke_Times, Toke_MsgOp, Toke_ListSep, Toke_Crap, \
    Toke_Semicolon, Toke_Portamento, Toke_Deref, Toke_False, Toke_Whitespace, \
    Toke_AlCoda, Toke_RWing, Toke_OctaveShift, Toke_SkoarpionEnd, Toke_EOF, \
    Toke_DynPiano


class SkoarParseException(Exception):
    pass


class SkoarParser:

    def __init__(self, runtime):
        self.runtime = runtime
        self.toker = runtime.toker
        self.tab = 0
        self.desirables = dict()
        self.init_desirables()

    def fail(self):
        self.toker.dump()
        raise SkoarParseException

    @property
    def tabby(self):
        if self.tab == 0:
            return ""

        return ("{:>" + str(self.tab * 2) + "}").format(" ")

    def print(self, line, end):
        print(self.tabby + line, end=end)


    def init_desirables(self):

        # beat
        self.desirables['beat -> Crotchets'] = [Toke_Crotchets]
        self.desirables['beat -> Quavers'] = [Toke_Quavers]
        self.desirables['beat -> Quarters'] = [Toke_Quarters]
        self.desirables['beat -> Eighths'] = [Toke_Eighths]
        self.desirables['beat -> Slash'] = [Toke_Slash]

        # loop
        self.desirables['loop -> LoopS loop_body loop_condition LoopE'] = [Toke_LoopS]

        # skrp_sig
        self.desirables['skrp_sig -> ArgSpec SkoarpionSep'] = [Toke_ArgSpec]
        self.desirables['skrp_sig -> SymbolName opt_arg_spec SkoarpionSep'] = [Toke_SymbolName]

        # skoarpion
        self.desirables['skoarpion -> SkoarpionStart skrp_sig skrp_suffix'] = [Toke_SkoarpionStart]

        # listy_entries
        self.desirables['listy_entries -> expr moar_listy_entries'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]

        # expr
        self.desirables['expr -> msgable expr_prime'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]

        # cthulhu
        self.desirables['cthulhu -> LWing Semicolon cthulhu_prime'] = [Toke_LWing]

        # boolean
        self.desirables['boolean -> BooleanOp expr'] = [Toke_BooleanOp]

        # expr_prime
        self.desirables['expr_prime -> assignment expr_prime'] = [Toke_AssOp]
        self.desirables['expr_prime -> math expr_prime'] = [Toke_MathOp]
        self.desirables['expr_prime -> boolean'] = [Toke_BooleanOp]
        self.desirables['expr_prime -> times'] = [Toke_Times]

        # cond_else
        self.desirables['cond_else -> CondIf if_body'] = [Toke_CondIf]

        # boolean_expr
        self.desirables['boolean_expr -> expr'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]

        # musical_keyword
        self.desirables['musical_keyword -> dynamic'] = [Toke_DynSFZ, Toke_DynForte, Toke_DynFP, Toke_DynPiano]
        self.desirables['musical_keyword -> ottavas'] = [Toke_Loco, Toke_QuindicesimaA, Toke_OttavaA, Toke_QuindicesimaB, Toke_OctaveShift,
                   Toke_OttavaB]
        self.desirables['musical_keyword -> pedally'] = [Toke_PedalUp, Toke_PedalDown]
        self.desirables['musical_keyword -> musical_keyword_misc'] = [Toke_Rep, Toke_Portamento, Toke_Carrot]

        # phrasey
        self.desirables['phrasey -> Comment'] = [Toke_Comment]
        self.desirables['phrasey -> marker'] = [Toke_Bars, Toke_Coda, Toke_Volta, Toke_Segno, Toke_Fine]
        self.desirables['phrasey -> Meter'] = [Toke_Meter]
        self.desirables['phrasey -> expr'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]
        self.desirables['phrasey -> dal_goto'] = [Toke_DaCapo, Toke_DalSegno]
        self.desirables['phrasey -> beat'] = [Toke_Quarters, Toke_Crotchets, Toke_Quavers, Toke_Eighths, Toke_Slash]

        # conditional
        self.desirables['conditional -> CondS cond_ifs CondE'] = [Toke_CondS]

        # skrp_moar_lines
        self.desirables['skrp_moar_lines -> Newline skrp_lines'] = [Toke_Newline]

        # optional_voice
        self.desirables['optional_voice -> Voice'] = [Toke_Voice]

        # skrp_lines
        self.desirables['skrp_lines -> optional_voice phrases skrp_moar_lines'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta, Toke_CondS,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Newline, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_SkoarpionEnd, Toke_DynPiano]

        # math
        self.desirables['math -> MathOp msgable'] = [Toke_MathOp]

        # musical_keyword_misc
        self.desirables['musical_keyword_misc -> Rep'] = [Toke_Rep]
        self.desirables['musical_keyword_misc -> Portamento'] = [Toke_Portamento]
        self.desirables['musical_keyword_misc -> Carrot'] = [Toke_Carrot]

        # cthulhu_prime
        self.desirables['cthulhu_prime -> boolean_expr Semicolon RWing'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]
        self.desirables['cthulhu_prime -> Nosey Semicolon RWing'] = [Toke_Nosey]

        # cond_ifs
        self.desirables['cond_ifs -> cond_if cond_ifs_suffix'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Freq, Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_DynPiano]

        # deref
        self.desirables['deref -> Deref deref_prime'] = [Toke_Deref]

        # listy
        self.desirables['listy -> ListS listy_suffix'] = [Toke_ListS]

        # settable
        self.desirables['settable -> Caesura'] = [Toke_Caesura]
        self.desirables['settable -> Symbol'] = [Toke_Symbol]
        self.desirables['settable -> listy'] = [Toke_ListS]
        self.desirables['settable -> Quarters'] = [Toke_Quarters]
        self.desirables['settable -> Eighths'] = [Toke_Eighths]
        self.desirables['settable -> Fairy'] = [Toke_Fairy]

        # deref_prime
        self.desirables['deref_prime -> MsgNameWithArgs listy_suffix'] = [Toke_MsgNameWithArgs]
        self.desirables['deref_prime -> MsgName'] = [Toke_MsgName]

        # branches
        self.desirables['branches -> branch branches'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta, Toke_CondS,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Newline, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_DynPiano]

        # optional_al_coda
        self.desirables['optional_al_coda -> AlCoda'] = [Toke_AlCoda]

        # coda
        self.desirables['coda -> Coda optional_al_coda'] = [Toke_Coda]

        # cond_if
        self.desirables['cond_if -> optional_voice boolean_expr CondIf if_body cond_else'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Freq, Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_DynPiano]

        # cond_ifs_suffix
        self.desirables['cond_ifs_suffix -> Newline cond_ifs'] = [Toke_Newline]

        # if_body
        self.desirables['if_body -> phrases'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta, Toke_CondS,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Newline, Toke_Caesura, Toke_True, Toke_CondIf,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_CondE, Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift,
                   Toke_Portamento, Toke_DynPiano]

        # msg_chain_node
        self.desirables['msg_chain_node -> MsgOp msg msg_chain_node'] = [Toke_MsgOp]

        # al_x
        self.desirables['al_x -> AlCoda'] = [Toke_AlCoda]
        self.desirables['al_x -> AlSegno'] = [Toke_AlSegno]
        self.desirables['al_x -> AlFine'] = [Toke_AlFine]

        # skrp_suffix
        self.desirables['skrp_suffix -> skrp_lines SkoarpionEnd'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta, Toke_CondS,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Newline, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_SkoarpionEnd, Toke_DynPiano]

        # marker
        self.desirables['marker -> Segno'] = [Toke_Segno]
        self.desirables['marker -> Fine'] = [Toke_Fine]
        self.desirables['marker -> coda'] = [Toke_Coda]
        self.desirables['marker -> Volta'] = [Toke_Volta]
        self.desirables['marker -> Bars'] = [Toke_Bars]

        # dynamic
        self.desirables['dynamic -> DynPiano'] = [Toke_DynPiano]
        self.desirables['dynamic -> DynForte'] = [Toke_DynForte]
        self.desirables['dynamic -> DynSFZ'] = [Toke_DynSFZ]
        self.desirables['dynamic -> DynFP'] = [Toke_DynFP]

        # phrases
        self.desirables['phrases -> phrasey phrases'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Volta, Toke_CondS, Toke_Choard,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_HashLevel, Toke_OttavaB, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Caesura, Toke_True, Toke_Meter, Toke_Crotchets,
                   Toke_Freq, Toke_ListS, Toke_QuindicesimaB, Toke_Quavers, Toke_Eighths,
                   Toke_Symbol, Toke_DalSegno, Toke_LWing, Toke_Crap, Toke_Deref,
                   Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]

        # skoar
        self.desirables['skoar -> branches'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta, Toke_CondS,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Newline, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_EOF, Toke_DynPiano]

        # ottavas
        self.desirables['ottavas -> OctaveShift'] = [Toke_OctaveShift]
        self.desirables['ottavas -> OttavaA'] = [Toke_OttavaA]
        self.desirables['ottavas -> OttavaB'] = [Toke_OttavaB]
        self.desirables['ottavas -> QuindicesimaA'] = [Toke_QuindicesimaA]
        self.desirables['ottavas -> QuindicesimaB'] = [Toke_QuindicesimaB]
        self.desirables['ottavas -> Loco'] = [Toke_Loco]

        # listy_suffix
        self.desirables['listy_suffix -> listy_entries ListE'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]
        self.desirables['listy_suffix -> ListE'] = [Toke_ListE]

        # pedally
        self.desirables['pedally -> PedalDown'] = [Toke_PedalDown]
        self.desirables['pedally -> PedalUp'] = [Toke_PedalUp]

        # loop_condition
        self.desirables['loop_condition -> LoopSep boolean_expr'] = [Toke_LoopSep]

        # assignment
        self.desirables['assignment -> AssOp settable'] = [Toke_AssOp]

        # opt_arg_spec
        self.desirables['opt_arg_spec -> ArgSpec'] = [Toke_ArgSpec]

        # dal_goto
        self.desirables['dal_goto -> DaCapo al_x'] = [Toke_DaCapo]
        self.desirables['dal_goto -> DalSegno al_x'] = [Toke_DalSegno]

        # msg
        self.desirables['msg -> MsgNameWithArgs listy_suffix'] = [Toke_MsgNameWithArgs]
        self.desirables['msg -> MsgName'] = [Toke_MsgName]
        self.desirables['msg -> listy'] = [Toke_ListS]
        self.desirables['msg -> loop'] = [Toke_LoopS]

        # msgable
        self.desirables['msgable -> nouny msg_chain_node'] = [Toke_Float, Toke_LoopS, Toke_SkoarpionStart, Toke_DynFP, Toke_DynSFZ,
                   Toke_Rep, Toke_Tuplet, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_CondS, Toke_Choard, Toke_QuindicesimaA, Toke_String,
                   Toke_DynForte, Toke_Carrot, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_Caesura, Toke_True, Toke_Freq,
                   Toke_ListS, Toke_QuindicesimaB, Toke_Symbol, Toke_LWing, Toke_Crap,
                   Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento, Toke_DynPiano]

        # nouny_literal
        self.desirables['nouny_literal -> Tuplet'] = [Toke_Tuplet]
        self.desirables['nouny_literal -> Caesura'] = [Toke_Caesura]
        self.desirables['nouny_literal -> Freq'] = [Toke_Freq]
        self.desirables['nouny_literal -> Int'] = [Toke_Int]
        self.desirables['nouny_literal -> Float'] = [Toke_Float]
        self.desirables['nouny_literal -> String'] = [Toke_String]
        self.desirables['nouny_literal -> Choard'] = [Toke_Choard]
        self.desirables['nouny_literal -> NamedNoat'] = [Toke_NamedNoat]
        self.desirables['nouny_literal -> Symbol'] = [Toke_Symbol]
        self.desirables['nouny_literal -> Fairy'] = [Toke_Fairy]
        self.desirables['nouny_literal -> HashLevel'] = [Toke_HashLevel]
        self.desirables['nouny_literal -> False'] = [Toke_False]
        self.desirables['nouny_literal -> True'] = [Toke_True]
        self.desirables['nouny_literal -> Crap'] = [Toke_Crap]

        # moar_listy_entries
        self.desirables['moar_listy_entries -> ListSep listy_entries'] = [Toke_ListSep]
        self.desirables['moar_listy_entries -> Newline'] = [Toke_Newline]

        # nouny
        self.desirables['nouny -> cthulhu'] = [Toke_LWing]
        self.desirables['nouny -> conditional'] = [Toke_CondS]
        self.desirables['nouny -> loop'] = [Toke_LoopS]
        self.desirables['nouny -> nouny_literal'] = [Toke_HashLevel, Toke_Float, Toke_Symbol, Toke_NamedNoat, Toke_Int,
                   Toke_Fairy, Toke_Caesura, Toke_True, Toke_Crap, Toke_Choard,
                   Toke_False, Toke_Freq, Toke_String, Toke_Tuplet]
        self.desirables['nouny -> musical_keyword'] = [Toke_OttavaB, Toke_Loco, Toke_PedalUp, Toke_PedalDown, Toke_OttavaA,
                   Toke_DynFP, Toke_DynSFZ, Toke_QuindicesimaA, Toke_DynForte, Toke_QuindicesimaB,
                   Toke_Rep, Toke_OctaveShift, Toke_Portamento, Toke_Carrot, Toke_DynPiano]
        self.desirables['nouny -> listy'] = [Toke_ListS]
        self.desirables['nouny -> deref'] = [Toke_Deref]
        self.desirables['nouny -> skoarpion'] = [Toke_SkoarpionStart]

        # loop_body
        self.desirables['loop_body -> phrases'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_LoopSep, Toke_Rep,
                   Toke_Tuplet, Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown,
                   Toke_OttavaA, Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta,
                   Toke_CondS, Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash,
                   Toke_Carrot, Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp,
                   Toke_Int, Toke_Fairy, Toke_LoopE, Toke_Caesura, Toke_True,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_DynPiano]

        # times
        self.desirables['times -> Times'] = [Toke_Times]

        # branch
        self.desirables['branch -> optional_voice phrases Newline'] = [Toke_Float, Toke_Segno, Toke_LoopS, Toke_Bars, Toke_SkoarpionStart,
                   Toke_DynFP, Toke_Coda, Toke_DynSFZ, Toke_Rep, Toke_Tuplet,
                   Toke_Quarters, Toke_Loco, Toke_NamedNoat, Toke_PedalDown, Toke_OttavaA,
                   Toke_DaCapo, Toke_Comment, Toke_Choard, Toke_Volta, Toke_CondS,
                   Toke_QuindicesimaA, Toke_String, Toke_DynForte, Toke_Slash, Toke_Carrot,
                   Toke_Fine, Toke_OttavaB, Toke_HashLevel, Toke_PedalUp, Toke_Int,
                   Toke_Fairy, Toke_Newline, Toke_Voice, Toke_Caesura, Toke_True,
                   Toke_Meter, Toke_Crotchets, Toke_Freq, Toke_ListS, Toke_QuindicesimaB,
                   Toke_Quavers, Toke_Eighths, Toke_Symbol, Toke_DalSegno, Toke_LWing,
                   Toke_Crap, Toke_Deref, Toke_False, Toke_OctaveShift, Toke_Portamento,
                   Toke_DynPiano]

    def beat(self, parent):
        self.tab += 1
        noad = SkoarNoad('beat', parent)

        desires = self.desirables['beat -> Crotchets']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Crotchets', self.toker.burn(Toke_Crotchets))
            return noad

        desires = self.desirables['beat -> Quavers']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Quavers', self.toker.burn(Toke_Quavers))
            return noad

        desires = self.desirables['beat -> Quarters']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Quarters', self.toker.burn(Toke_Quarters))
            return noad

        desires = self.desirables['beat -> Eighths']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Eighths', self.toker.burn(Toke_Eighths))
            return noad

        desires = self.desirables['beat -> Slash']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Slash', self.toker.burn(Toke_Slash))
            return noad

        # Error State
        self.fail()

    def loop(self, parent):
        self.tab += 1
        noad = SkoarNoad('loop', parent)

        desires = self.desirables['loop -> LoopS loop_body loop_condition LoopE']
        if self.toker.sees(desires):
            noad.add_toke('Toke_LoopS', self.toker.burn(Toke_LoopS))
            noad.add_noad(self.loop_body(noad))
            noad.add_noad(self.loop_condition(noad))
            noad.add_toke('Toke_LoopE', self.toker.burn(Toke_LoopE))
            return noad

        # Error State
        self.fail()

    def skrp_sig(self, parent):
        self.tab += 1
        noad = SkoarNoad('skrp_sig', parent)

        desires = self.desirables['skrp_sig -> ArgSpec SkoarpionSep']
        if self.toker.sees(desires):
            noad.add_toke('Toke_ArgSpec', self.toker.burn(Toke_ArgSpec))
            noad.add_toke('Toke_SkoarpionSep', self.toker.burn(Toke_SkoarpionSep))
            return noad

        desires = self.desirables['skrp_sig -> SymbolName opt_arg_spec SkoarpionSep']
        if self.toker.sees(desires):
            noad.add_toke('Toke_SymbolName', self.toker.burn(Toke_SymbolName))
            noad.add_noad(self.opt_arg_spec(noad))
            noad.add_toke('Toke_SkoarpionSep', self.toker.burn(Toke_SkoarpionSep))
            return noad

        # <e>
        return noad

    def skoarpion(self, parent):
        self.tab += 1
        noad = SkoarNoad('skoarpion', parent)

        desires = self.desirables['skoarpion -> SkoarpionStart skrp_sig skrp_suffix']
        if self.toker.sees(desires):
            noad.add_toke('Toke_SkoarpionStart', self.toker.burn(Toke_SkoarpionStart))
            noad.add_noad(self.skrp_sig(noad))
            noad.add_noad(self.skrp_suffix(noad))
            return noad

        # Error State
        self.fail()

    def listy_entries(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['listy_entries -> expr moar_listy_entries']
        if self.toker.sees(desires):
            noad.add_noad(self.expr(noad))
            self.moar_listy_entries(noad)
            return noad

        # Error State
        self.fail()

    def expr(self, parent):
        self.tab += 1
        noad = SkoarNoad('expr', parent)

        desires = self.desirables['expr -> msgable expr_prime']
        if self.toker.sees(desires):
            noad.add_noad(self.msgable(noad))
            noad.add_noad(self.expr_prime(noad))
            return noad

        # Error State
        self.fail()

    def cthulhu(self, parent):
        self.tab += 1
        noad = SkoarNoad('cthulhu', parent)

        desires = self.desirables['cthulhu -> LWing Semicolon cthulhu_prime']
        if self.toker.sees(desires):
            noad.add_toke('Toke_LWing', self.toker.burn(Toke_LWing))
            noad.add_toke('Toke_Semicolon', self.toker.burn(Toke_Semicolon))
            self.cthulhu_prime(noad)
            return noad

        # Error State
        self.fail()

    def boolean(self, parent):
        self.tab += 1
        noad = SkoarNoad('boolean', parent)

        desires = self.desirables['boolean -> BooleanOp expr']
        if self.toker.sees(desires):
            noad.add_toke('Toke_BooleanOp', self.toker.burn(Toke_BooleanOp))
            noad.add_noad(self.expr(noad))
            return noad

        # Error State
        self.fail()

    def expr_prime(self, parent):
        self.tab += 1
        noad = SkoarNoad('expr_prime', parent)

        desires = self.desirables['expr_prime -> assignment expr_prime']
        if self.toker.sees(desires):
            noad.add_noad(self.assignment(noad))
            noad.add_noad(self.expr_prime(noad))
            return noad

        desires = self.desirables['expr_prime -> math expr_prime']
        if self.toker.sees(desires):
            noad.add_noad(self.math(noad))
            noad.add_noad(self.expr_prime(noad))
            return noad

        desires = self.desirables['expr_prime -> boolean']
        if self.toker.sees(desires):
            noad.add_noad(self.boolean(noad))
            return noad

        desires = self.desirables['expr_prime -> times']
        if self.toker.sees(desires):
            noad.add_noad(self.times(noad))
            return noad

        # <e>
        return noad

    def cond_else(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['cond_else -> CondIf if_body']
        if self.toker.sees(desires):
            noad.add_toke('Toke_CondIf', self.toker.burn(Toke_CondIf))
            noad.add_noad(self.if_body(noad))
            return noad

        # <e>
        return noad

    def boolean_expr(self, parent):
        self.tab += 1
        noad = SkoarNoad('boolean_expr', parent)

        desires = self.desirables['boolean_expr -> expr']
        if self.toker.sees(desires):
            noad.add_noad(self.expr(noad))
            return noad

        # Error State
        self.fail()

    def musical_keyword(self, parent):
        self.tab += 1
        noad = SkoarNoad('musical_keyword', parent)

        desires = self.desirables['musical_keyword -> dynamic']
        if self.toker.sees(desires):
            noad.add_noad(self.dynamic(noad))
            return noad

        desires = self.desirables['musical_keyword -> ottavas']
        if self.toker.sees(desires):
            noad.add_noad(self.ottavas(noad))
            return noad

        desires = self.desirables['musical_keyword -> pedally']
        if self.toker.sees(desires):
            noad.add_noad(self.pedally(noad))
            return noad

        desires = self.desirables['musical_keyword -> musical_keyword_misc']
        if self.toker.sees(desires):
            noad.add_noad(self.musical_keyword_misc(noad))
            return noad

        # Error State
        self.fail()

    def phrasey(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['phrasey -> Comment']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Comment', self.toker.burn(Toke_Comment))
            return noad

        desires = self.desirables['phrasey -> marker']
        if self.toker.sees(desires):
            noad.add_noad(self.marker(noad))
            return noad

        desires = self.desirables['phrasey -> Meter']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Meter', self.toker.burn(Toke_Meter))
            return noad

        desires = self.desirables['phrasey -> expr']
        if self.toker.sees(desires):
            noad.add_noad(self.expr(noad))
            return noad

        desires = self.desirables['phrasey -> dal_goto']
        if self.toker.sees(desires):
            noad.add_noad(self.dal_goto(noad))
            return noad

        desires = self.desirables['phrasey -> beat']
        if self.toker.sees(desires):
            noad.add_noad(self.beat(noad))
            return noad

        # Error State
        self.fail()

    def conditional(self, parent):
        self.tab += 1
        noad = SkoarNoad('conditional', parent)

        desires = self.desirables['conditional -> CondS cond_ifs CondE']
        if self.toker.sees(desires):
            noad.add_toke('Toke_CondS', self.toker.burn(Toke_CondS))
            self.cond_ifs(noad)
            noad.add_toke('Toke_CondE', self.toker.burn(Toke_CondE))
            return noad

        # Error State
        self.fail()

    def skrp_moar_lines(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['skrp_moar_lines -> Newline skrp_lines']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Newline', self.toker.burn(Toke_Newline))
            self.skrp_lines(noad)
            return noad

        # <e>
        return noad

    def optional_voice(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['optional_voice -> Voice']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Voice', self.toker.burn(Toke_Voice))
            return noad

        # <e>
        return noad

    def skrp_lines(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['skrp_lines -> optional_voice phrases skrp_moar_lines']
        if self.toker.sees(desires):
            self.optional_voice(noad)
            self.phrases(noad)
            self.skrp_moar_lines(noad)
            return noad

        # Error State
        self.fail()

    def math(self, parent):
        self.tab += 1
        noad = SkoarNoad('math', parent)

        desires = self.desirables['math -> MathOp msgable']
        if self.toker.sees(desires):
            noad.add_toke('Toke_MathOp', self.toker.burn(Toke_MathOp))
            noad.add_noad(self.msgable(noad))
            return noad

        # Error State
        self.fail()

    def musical_keyword_misc(self, parent):
        self.tab += 1
        noad = SkoarNoad('musical_keyword_misc', parent)

        desires = self.desirables['musical_keyword_misc -> Rep']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Rep', self.toker.burn(Toke_Rep))
            return noad

        desires = self.desirables['musical_keyword_misc -> Portamento']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Portamento', self.toker.burn(Toke_Portamento))
            return noad

        desires = self.desirables['musical_keyword_misc -> Carrot']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Carrot', self.toker.burn(Toke_Carrot))
            return noad

        # Error State
        self.fail()

    def cthulhu_prime(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['cthulhu_prime -> boolean_expr Semicolon RWing']
        if self.toker.sees(desires):
            noad.add_noad(self.boolean_expr(noad))
            noad.add_toke('Toke_Semicolon', self.toker.burn(Toke_Semicolon))
            noad.add_toke('Toke_RWing', self.toker.burn(Toke_RWing))
            return noad

        desires = self.desirables['cthulhu_prime -> Nosey Semicolon RWing']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Nosey', self.toker.burn(Toke_Nosey))
            noad.add_toke('Toke_Semicolon', self.toker.burn(Toke_Semicolon))
            noad.add_toke('Toke_RWing', self.toker.burn(Toke_RWing))
            return noad

        # Error State
        self.fail()

    def cond_ifs(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['cond_ifs -> cond_if cond_ifs_suffix']
        if self.toker.sees(desires):
            noad.add_noad(self.cond_if(noad))
            self.cond_ifs_suffix(noad)
            return noad

        # Error State
        self.fail()

    def deref(self, parent):
        self.tab += 1
        noad = SkoarNoad('deref', parent)

        desires = self.desirables['deref -> Deref deref_prime']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Deref', self.toker.burn(Toke_Deref))
            self.deref_prime(noad)
            return noad

        # Error State
        self.fail()

    def listy(self, parent):
        self.tab += 1
        noad = SkoarNoad('listy', parent)

        desires = self.desirables['listy -> ListS listy_suffix']
        if self.toker.sees(desires):
            noad.add_toke('Toke_ListS', self.toker.burn(Toke_ListS))
            self.listy_suffix(noad)
            return noad

        # Error State
        self.fail()

    def settable(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['settable -> Caesura']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Caesura', self.toker.burn(Toke_Caesura))
            return noad

        desires = self.desirables['settable -> Symbol']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Symbol', self.toker.burn(Toke_Symbol))
            return noad

        desires = self.desirables['settable -> listy']
        if self.toker.sees(desires):
            noad.add_noad(self.listy(noad))
            return noad

        desires = self.desirables['settable -> Quarters']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Quarters', self.toker.burn(Toke_Quarters))
            return noad

        desires = self.desirables['settable -> Eighths']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Eighths', self.toker.burn(Toke_Eighths))
            return noad

        desires = self.desirables['settable -> Fairy']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Fairy', self.toker.burn(Toke_Fairy))
            return noad

        # Error State
        self.fail()

    def deref_prime(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['deref_prime -> MsgNameWithArgs listy_suffix']
        if self.toker.sees(desires):
            noad.add_toke('Toke_MsgNameWithArgs', self.toker.burn(Toke_MsgNameWithArgs))
            self.listy_suffix(noad)
            return noad

        desires = self.desirables['deref_prime -> MsgName']
        if self.toker.sees(desires):
            noad.add_toke('Toke_MsgName', self.toker.burn(Toke_MsgName))
            return noad

        # Error State
        self.fail()

    def branches(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['branches -> branch branches']
        if self.toker.sees(desires):
            noad.add_noad(self.branch(noad))
            self.branches(noad)
            return noad

        # <e>
        return noad

    def optional_al_coda(self, parent):
        self.tab += 1
        noad = SkoarNoad('optional_al_coda', parent)

        desires = self.desirables['optional_al_coda -> AlCoda']
        if self.toker.sees(desires):
            noad.add_toke('Toke_AlCoda', self.toker.burn(Toke_AlCoda))
            return noad

        # <e>
        return noad

    def coda(self, parent):
        self.tab += 1
        noad = SkoarNoad('coda', parent)

        desires = self.desirables['coda -> Coda optional_al_coda']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Coda', self.toker.burn(Toke_Coda))
            noad.add_noad(self.optional_al_coda(noad))
            return noad

        # Error State
        self.fail()

    def cond_if(self, parent):
        self.tab += 1
        noad = SkoarNoad('cond_if', parent)

        desires = self.desirables['cond_if -> optional_voice boolean_expr CondIf if_body cond_else']
        if self.toker.sees(desires):
            self.optional_voice(noad)
            noad.add_noad(self.boolean_expr(noad))
            noad.add_toke('Toke_CondIf', self.toker.burn(Toke_CondIf))
            noad.add_noad(self.if_body(noad))
            self.cond_else(noad)
            return noad

        # Error State
        self.fail()

    def cond_ifs_suffix(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['cond_ifs_suffix -> Newline cond_ifs']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Newline', self.toker.burn(Toke_Newline))
            self.cond_ifs(noad)
            return noad

        # <e>
        return noad

    def if_body(self, parent):
        self.tab += 1
        noad = SkoarNoad('if_body', parent)

        desires = self.desirables['if_body -> phrases']
        if self.toker.sees(desires):
            self.phrases(noad)
            return noad

        # Error State
        self.fail()

    def msg_chain_node(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['msg_chain_node -> MsgOp msg msg_chain_node']
        if self.toker.sees(desires):
            noad.add_toke('Toke_MsgOp', self.toker.burn(Toke_MsgOp))
            noad.add_noad(self.msg(noad))
            self.msg_chain_node(noad)
            return noad

        # <e>
        return noad

    def al_x(self, parent):
        self.tab += 1
        noad = SkoarNoad('al_x', parent)

        desires = self.desirables['al_x -> AlCoda']
        if self.toker.sees(desires):
            noad.add_toke('Toke_AlCoda', self.toker.burn(Toke_AlCoda))
            return noad

        desires = self.desirables['al_x -> AlSegno']
        if self.toker.sees(desires):
            noad.add_toke('Toke_AlSegno', self.toker.burn(Toke_AlSegno))
            return noad

        desires = self.desirables['al_x -> AlFine']
        if self.toker.sees(desires):
            noad.add_toke('Toke_AlFine', self.toker.burn(Toke_AlFine))
            return noad

        # <e>
        return noad

    def skrp_suffix(self, parent):
        self.tab += 1
        noad = SkoarNoad('skrp_suffix', parent)

        desires = self.desirables['skrp_suffix -> skrp_lines SkoarpionEnd']
        if self.toker.sees(desires):
            self.skrp_lines(noad)
            noad.add_toke('Toke_SkoarpionEnd', self.toker.burn(Toke_SkoarpionEnd))
            return noad

        # Error State
        self.fail()

    def marker(self, parent):
        self.tab += 1
        noad = SkoarNoad('marker', parent)

        desires = self.desirables['marker -> Segno']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Segno', self.toker.burn(Toke_Segno))
            return noad

        desires = self.desirables['marker -> Fine']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Fine', self.toker.burn(Toke_Fine))
            return noad

        desires = self.desirables['marker -> coda']
        if self.toker.sees(desires):
            noad.add_noad(self.coda(noad))
            return noad

        desires = self.desirables['marker -> Volta']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Volta', self.toker.burn(Toke_Volta))
            return noad

        desires = self.desirables['marker -> Bars']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Bars', self.toker.burn(Toke_Bars))
            return noad

        # Error State
        self.fail()

    def dynamic(self, parent):
        self.tab += 1
        noad = SkoarNoad('dynamic', parent)

        desires = self.desirables['dynamic -> DynPiano']
        if self.toker.sees(desires):
            noad.add_toke('Toke_DynPiano', self.toker.burn(Toke_DynPiano))
            return noad

        desires = self.desirables['dynamic -> DynForte']
        if self.toker.sees(desires):
            noad.add_toke('Toke_DynForte', self.toker.burn(Toke_DynForte))
            return noad

        desires = self.desirables['dynamic -> DynSFZ']
        if self.toker.sees(desires):
            noad.add_toke('Toke_DynSFZ', self.toker.burn(Toke_DynSFZ))
            return noad

        desires = self.desirables['dynamic -> DynFP']
        if self.toker.sees(desires):
            noad.add_toke('Toke_DynFP', self.toker.burn(Toke_DynFP))
            return noad

        # Error State
        self.fail()

    def phrases(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['phrases -> phrasey phrases']
        if self.toker.sees(desires):
            self.phrasey(noad)
            self.phrases(noad)
            return noad

        # <e>
        return noad

    def skoar(self, parent):
        self.tab += 1
        noad = SkoarNoad('skoar', parent)

        desires = self.desirables['skoar -> branches']
        if self.toker.sees(desires):
            self.branches(noad)
            return noad

        # Error State
        self.fail()

    def ottavas(self, parent):
        self.tab += 1
        noad = SkoarNoad('ottavas', parent)

        desires = self.desirables['ottavas -> OctaveShift']
        if self.toker.sees(desires):
            noad.add_toke('Toke_OctaveShift', self.toker.burn(Toke_OctaveShift))
            return noad

        desires = self.desirables['ottavas -> OttavaA']
        if self.toker.sees(desires):
            noad.add_toke('Toke_OttavaA', self.toker.burn(Toke_OttavaA))
            return noad

        desires = self.desirables['ottavas -> OttavaB']
        if self.toker.sees(desires):
            noad.add_toke('Toke_OttavaB', self.toker.burn(Toke_OttavaB))
            return noad

        desires = self.desirables['ottavas -> QuindicesimaA']
        if self.toker.sees(desires):
            noad.add_toke('Toke_QuindicesimaA', self.toker.burn(Toke_QuindicesimaA))
            return noad

        desires = self.desirables['ottavas -> QuindicesimaB']
        if self.toker.sees(desires):
            noad.add_toke('Toke_QuindicesimaB', self.toker.burn(Toke_QuindicesimaB))
            return noad

        desires = self.desirables['ottavas -> Loco']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Loco', self.toker.burn(Toke_Loco))
            return noad

        # Error State
        self.fail()

    def listy_suffix(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['listy_suffix -> listy_entries ListE']
        if self.toker.sees(desires):
            self.listy_entries(noad)
            noad.add_toke('Toke_ListE', self.toker.burn(Toke_ListE))
            return noad

        desires = self.desirables['listy_suffix -> ListE']
        if self.toker.sees(desires):
            noad.add_toke('Toke_ListE', self.toker.burn(Toke_ListE))
            return noad

        # Error State
        self.fail()

    def pedally(self, parent):
        self.tab += 1
        noad = SkoarNoad('pedally', parent)

        desires = self.desirables['pedally -> PedalDown']
        if self.toker.sees(desires):
            noad.add_toke('Toke_PedalDown', self.toker.burn(Toke_PedalDown))
            return noad

        desires = self.desirables['pedally -> PedalUp']
        if self.toker.sees(desires):
            noad.add_toke('Toke_PedalUp', self.toker.burn(Toke_PedalUp))
            return noad

        # Error State
        self.fail()

    def loop_condition(self, parent):
        self.tab += 1
        noad = SkoarNoad('loop_condition', parent)

        desires = self.desirables['loop_condition -> LoopSep boolean_expr']
        if self.toker.sees(desires):
            noad.add_toke('Toke_LoopSep', self.toker.burn(Toke_LoopSep))
            noad.add_noad(self.boolean_expr(noad))
            return noad

        # <e>
        return noad

    def assignment(self, parent):
        self.tab += 1
        noad = SkoarNoad('assignment', parent)

        desires = self.desirables['assignment -> AssOp settable']
        if self.toker.sees(desires):
            noad.add_toke('Toke_AssOp', self.toker.burn(Toke_AssOp))
            self.settable(noad)
            return noad

        # Error State
        self.fail()

    def opt_arg_spec(self, parent):
        self.tab += 1
        noad = SkoarNoad('opt_arg_spec', parent)

        desires = self.desirables['opt_arg_spec -> ArgSpec']
        if self.toker.sees(desires):
            noad.add_toke('Toke_ArgSpec', self.toker.burn(Toke_ArgSpec))
            return noad

        # <e>
        return noad

    def dal_goto(self, parent):
        self.tab += 1
        noad = SkoarNoad('dal_goto', parent)

        desires = self.desirables['dal_goto -> DaCapo al_x']
        if self.toker.sees(desires):
            noad.add_toke('Toke_DaCapo', self.toker.burn(Toke_DaCapo))
            noad.add_noad(self.al_x(noad))
            return noad

        desires = self.desirables['dal_goto -> DalSegno al_x']
        if self.toker.sees(desires):
            noad.add_toke('Toke_DalSegno', self.toker.burn(Toke_DalSegno))
            noad.add_noad(self.al_x(noad))
            return noad

        # Error State
        self.fail()

    def msg(self, parent):
        self.tab += 1
        noad = SkoarNoad('msg', parent)

        desires = self.desirables['msg -> MsgNameWithArgs listy_suffix']
        if self.toker.sees(desires):
            noad.add_toke('Toke_MsgNameWithArgs', self.toker.burn(Toke_MsgNameWithArgs))
            self.listy_suffix(noad)
            return noad

        desires = self.desirables['msg -> MsgName']
        if self.toker.sees(desires):
            noad.add_toke('Toke_MsgName', self.toker.burn(Toke_MsgName))
            return noad

        desires = self.desirables['msg -> listy']
        if self.toker.sees(desires):
            noad.add_noad(self.listy(noad))
            return noad

        desires = self.desirables['msg -> loop']
        if self.toker.sees(desires):
            noad.add_noad(self.loop(noad))
            return noad

        # Error State
        self.fail()

    def msgable(self, parent):
        self.tab += 1
        noad = SkoarNoad('msgable', parent)

        desires = self.desirables['msgable -> nouny msg_chain_node']
        if self.toker.sees(desires):
            noad.add_noad(self.nouny(noad))
            self.msg_chain_node(noad)
            return noad

        # Error State
        self.fail()

    def nouny_literal(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['nouny_literal -> Tuplet']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Tuplet', self.toker.burn(Toke_Tuplet))
            return noad

        desires = self.desirables['nouny_literal -> Caesura']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Caesura', self.toker.burn(Toke_Caesura))
            return noad

        desires = self.desirables['nouny_literal -> Freq']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Freq', self.toker.burn(Toke_Freq))
            return noad

        desires = self.desirables['nouny_literal -> Int']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Int', self.toker.burn(Toke_Int))
            return noad

        desires = self.desirables['nouny_literal -> Float']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Float', self.toker.burn(Toke_Float))
            return noad

        desires = self.desirables['nouny_literal -> String']
        if self.toker.sees(desires):
            noad.add_toke('Toke_String', self.toker.burn(Toke_String))
            return noad

        desires = self.desirables['nouny_literal -> Choard']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Choard', self.toker.burn(Toke_Choard))
            return noad

        desires = self.desirables['nouny_literal -> NamedNoat']
        if self.toker.sees(desires):
            noad.add_toke('Toke_NamedNoat', self.toker.burn(Toke_NamedNoat))
            return noad

        desires = self.desirables['nouny_literal -> Symbol']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Symbol', self.toker.burn(Toke_Symbol))
            return noad

        desires = self.desirables['nouny_literal -> Fairy']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Fairy', self.toker.burn(Toke_Fairy))
            return noad

        desires = self.desirables['nouny_literal -> HashLevel']
        if self.toker.sees(desires):
            noad.add_toke('Toke_HashLevel', self.toker.burn(Toke_HashLevel))
            return noad

        desires = self.desirables['nouny_literal -> False']
        if self.toker.sees(desires):
            noad.add_toke('Toke_False', self.toker.burn(Toke_False))
            return noad

        desires = self.desirables['nouny_literal -> True']
        if self.toker.sees(desires):
            noad.add_toke('Toke_True', self.toker.burn(Toke_True))
            return noad

        desires = self.desirables['nouny_literal -> Crap']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Crap', self.toker.burn(Toke_Crap))
            return noad

        # Error State
        self.fail()

    def moar_listy_entries(self, parent):
        self.tab += 1
        noad = parent

        desires = self.desirables['moar_listy_entries -> ListSep listy_entries']
        if self.toker.sees(desires):
            noad.add_toke('Toke_ListSep', self.toker.burn(Toke_ListSep))
            self.listy_entries(noad)
            return noad

        desires = self.desirables['moar_listy_entries -> Newline']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Newline', self.toker.burn(Toke_Newline))
            return noad

        # <e>
        return noad

    def nouny(self, parent):
        self.tab += 1
        noad = SkoarNoad('nouny', parent)

        desires = self.desirables['nouny -> cthulhu']
        if self.toker.sees(desires):
            noad.add_noad(self.cthulhu(noad))
            return noad

        desires = self.desirables['nouny -> conditional']
        if self.toker.sees(desires):
            noad.add_noad(self.conditional(noad))
            return noad

        desires = self.desirables['nouny -> loop']
        if self.toker.sees(desires):
            noad.add_noad(self.loop(noad))
            return noad

        desires = self.desirables['nouny -> nouny_literal']
        if self.toker.sees(desires):
            self.nouny_literal(noad)
            return noad

        desires = self.desirables['nouny -> musical_keyword']
        if self.toker.sees(desires):
            noad.add_noad(self.musical_keyword(noad))
            return noad

        desires = self.desirables['nouny -> listy']
        if self.toker.sees(desires):
            noad.add_noad(self.listy(noad))
            return noad

        desires = self.desirables['nouny -> deref']
        if self.toker.sees(desires):
            noad.add_noad(self.deref(noad))
            return noad

        desires = self.desirables['nouny -> skoarpion']
        if self.toker.sees(desires):
            noad.add_noad(self.skoarpion(noad))
            return noad

        # Error State
        self.fail()

    def loop_body(self, parent):
        self.tab += 1
        noad = SkoarNoad('loop_body', parent)

        desires = self.desirables['loop_body -> phrases']
        if self.toker.sees(desires):
            self.phrases(noad)
            return noad

        # Error State
        self.fail()

    def times(self, parent):
        self.tab += 1
        noad = SkoarNoad('times', parent)

        desires = self.desirables['times -> Times']
        if self.toker.sees(desires):
            noad.add_toke('Toke_Times', self.toker.burn(Toke_Times))
            return noad

        # Error State
        self.fail()

    def branch(self, parent):
        self.tab += 1
        noad = SkoarNoad('branch', parent)

        desires = self.desirables['branch -> optional_voice phrases Newline']
        if self.toker.sees(desires):
            self.optional_voice(noad)
            self.phrases(noad)
            noad.add_toke('Toke_Newline', self.toker.burn(Toke_Newline))
            return noad

        # Error State
        self.fail()

